{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/candidateExperience.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getExperienceForCandidate(candidateId: string) {\n  const { data, error } = await supabase\n    .from(\"candidate_experience\")\n    .select(\"*\")\n    .eq(\"candidate_id\", candidateId)\n    .order(\"start_date\", { ascending: false });\n\n  if (error) throw error;\n  return data || [];\n}\n\nexport async function insertExperienceRecords(records: any[]) {\n  if (!records.length) return [];\n  const { data, error } = await supabase\n    .from(\"candidate_experience\")\n    .insert(records)\n    .select();\n\n  if (error) throw error;\n  return data || [];\n}\n\nexport async function deleteExperienceForCandidate(candidateId: string) {\n  const { error } = await supabase\n    .from(\"candidate_experience\")\n    .delete()\n    .eq(\"candidate_id\", candidateId);\n\n  if (error) throw error;\n  return true;\n}\n\nexport async function getAllCandidates() {\n  const { data, error } = await supabase.from(\"candidates\").select(\"*\");\n  if (error) throw error;\n  return data || [];\n}\n\nexport async function getCandidatesNeedingExperience(limit = 50) {\n  const { data, error } = await supabase\n    .rpc(\"candidates_needing_experience\", { p_limit: limit }); // si decides usar una funci√≥n\n  if (error) throw error;\n  return data || [];\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAEO,eAAe,0BAA0B,WAAmB;IACjE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,wBACL,MAAM,CAAC,KACP,EAAE,CAAC,gBAAgB,aACnB,KAAK,CAAC,cAAc;QAAE,WAAW;IAAM;IAE1C,IAAI,OAAO,MAAM;IACjB,OAAO,QAAQ,EAAE;AACnB;AAEO,eAAe,wBAAwB,OAAc;IAC1D,IAAI,CAAC,QAAQ,MAAM,EAAE,OAAO,EAAE;IAC9B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,wBACL,MAAM,CAAC,SACP,MAAM;IAET,IAAI,OAAO,MAAM;IACjB,OAAO,QAAQ,EAAE;AACnB;AAEO,eAAe,6BAA6B,WAAmB;IACpE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAC7B,IAAI,CAAC,wBACL,MAAM,GACN,EAAE,CAAC,gBAAgB;IAEtB,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,cAAc,MAAM,CAAC;IACjE,IAAI,OAAO,MAAM;IACjB,OAAO,QAAQ,EAAE;AACnB;AAEO,eAAe,+BAA+B,QAAQ,EAAE;IAC7D,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,GAAG,CAAC,iCAAiC;QAAE,SAAS;IAAM,IAAI,8BAA8B;IAC3F,IAAI,OAAO,MAAM;IACjB,OAAO,QAAQ,EAAE;AACnB"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/hyperconnectors.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getAllHyperconnectors() {\n  const { data, error } = await supabase.from(\"hyperconnectors\").select(\"*\");\n  if (error) throw error;\n  return data;\n}\n\nexport async function getHyperconnectorById(id: string) {\n  const { data, error } = await supabase.from(\"hyperconnectors\").select(\"*\").eq(\"id\", id).single();\n  if (error) throw error;\n  return data;\n}\n\nexport async function createHyperconnector(hci: any) {\n  const { data, error } = await supabase.from(\"hyperconnectors\").insert(hci).select().single();\n  if (error) throw error;\n\n  // Trigger relationship sync (non-blocking)\n  if (data?.id) {\n    import(\"../agents/syncHyperconnectorRelationships\")\n      .then(({ syncHyperconnectorCandidateRelationshipsForHyperconnector }) => {\n        syncHyperconnectorCandidateRelationshipsForHyperconnector(data.id).catch((err) => {\n          console.error(\"Error in background relationship sync after hyperconnector creation:\", err);\n        });\n      })\n      .catch((err) => {\n        console.error(\"Error loading relationship sync module:\", err);\n      });\n  }\n\n  return data;\n}\n\nexport async function updateHyperconnector(id: string, updates: any) {\n  const { data, error } = await supabase.from(\"hyperconnectors\").update(updates).eq(\"id\", id).select().single();\n  if (error) throw error;\n  return data;\n}\n\nexport async function deleteHyperconnector(id: string) {\n  const { error } = await supabase.from(\"hyperconnectors\").delete().eq(\"id\", id);\n  if (error) throw error;\n  return true;\n}\n\n/**\n * Upsert: crea o actualiza un hyperconnector por user_id, email o candidate_id\n */\nexport async function upsertHyperconnector(hyperconnectorData: {\n  user_id?: string;\n  email?: string;\n  full_name?: string;\n  candidate_id?: string;\n  linkedin_url?: string | null;\n  current_job_title?: string | null;\n  current_company?: string | null;\n  profile_picture_url?: string | null;\n}): Promise<any> {\n  // Buscar hyperconnector existente\n  let existing = null;\n\n  // Prioridad 1: Buscar por user_id (m√°s confiable)\n  if (hyperconnectorData.user_id) {\n    const { data } = await supabase\n      .from(\"hyperconnectors\")\n      .select(\"*\")\n      .eq(\"user_id\", hyperconnectorData.user_id)\n      .maybeSingle();\n    existing = data;\n  }\n\n  // Prioridad 2: Buscar por email si no se encontr√≥ por user_id\n  if (!existing && hyperconnectorData.email) {\n    const { data } = await supabase\n      .from(\"hyperconnectors\")\n      .select(\"*\")\n      .eq(\"email\", hyperconnectorData.email)\n      .maybeSingle();\n    existing = data;\n  }\n\n  // Prioridad 3: Buscar por candidate_id si no se encontr√≥ por user_id ni email\n  if (!existing && hyperconnectorData.candidate_id) {\n    const { data } = await supabase\n      .from(\"hyperconnectors\")\n      .select(\"*\")\n      .eq(\"candidate_id\", hyperconnectorData.candidate_id)\n      .maybeSingle();\n    existing = data;\n  }\n\n  if (existing) {\n    // Actualizar\n    const { data, error } = await supabase\n      .from(\"hyperconnectors\")\n      .update({\n        ...hyperconnectorData,\n        updated_at: new Date().toISOString(),\n      })\n      .eq(\"id\", existing.id)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  } else {\n    // Crear nuevo\n    return await createHyperconnector(hyperconnectorData);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;AAEO,eAAe;IACpB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC;IACtE,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,sBAAsB,EAAU;IACpD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC,KAAK,EAAE,CAAC,MAAM,IAAI,MAAM;IAC9F,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,qBAAqB,GAAQ;IACjD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC,KAAK,MAAM,GAAG,MAAM;IAC1F,IAAI,OAAO,MAAM;IAEjB,2CAA2C;IAC3C,IAAI,MAAM,IAAI;QACZ,sIACG,IAAI,CAAC,CAAC,EAAE,yDAAyD,EAAE;YAClE,0DAA0D,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC;gBACxE,QAAQ,KAAK,CAAC,wEAAwE;YACxF;QACF,GACC,KAAK,CAAC,CAAC;YACN,QAAQ,KAAK,CAAC,2CAA2C;QAC3D;IACJ;IAEA,OAAO;AACT;AAEO,eAAe,qBAAqB,EAAU,EAAE,OAAY;IACjE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC,SAAS,EAAE,CAAC,MAAM,IAAI,MAAM,GAAG,MAAM;IAC3G,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,qBAAqB,EAAU;IACnD,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,GAAG,EAAE,CAAC,MAAM;IAC3E,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAKO,eAAe,qBAAqB,kBAS1C;IACC,kCAAkC;IAClC,IAAI,WAAW;IAEf,kDAAkD;IAClD,IAAI,mBAAmB,OAAO,EAAE;QAC9B,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,yJAAQ,CAC5B,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,WAAW,mBAAmB,OAAO,EACxC,WAAW;QACd,WAAW;IACb;IAEA,8DAA8D;IAC9D,IAAI,CAAC,YAAY,mBAAmB,KAAK,EAAE;QACzC,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,yJAAQ,CAC5B,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,SAAS,mBAAmB,KAAK,EACpC,WAAW;QACd,WAAW;IACb;IAEA,8EAA8E;IAC9E,IAAI,CAAC,YAAY,mBAAmB,YAAY,EAAE;QAChD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,yJAAQ,CAC5B,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,gBAAgB,mBAAmB,YAAY,EAClD,WAAW;QACd,WAAW;IACb;IAEA,IAAI,UAAU;QACZ,aAAa;QACb,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,mBACL,MAAM,CAAC;YACN,GAAG,kBAAkB;YACrB,YAAY,IAAI,OAAO,WAAW;QACpC,GACC,EAAE,CAAC,MAAM,SAAS,EAAE,EACpB,MAAM,GACN,MAAM;QAET,IAAI,OAAO,MAAM;QACjB,OAAO;IACT,OAAO;QACL,cAAc;QACd,OAAO,MAAM,qBAAqB;IACpC;AACF"}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/agents/syncHyperconnectorRelationships.ts"],"sourcesContent":["/**\n * Service to automatically detect and sync relationships between hyperconnectors and candidates\n * based on overlapping work experience at the same company.\n * \n * Algorithm:\n * 1. For each (hyperconnector, candidate) pair:\n *    - Get all experience records for both\n *    - Find companies where they both worked (case-insensitive match)\n *    - Check if date ranges overlap\n *    - Calculate confidence_score based on overlap duration\n * 2. Insert into hyperconnector_candidates with:\n *    - relationship_type = 'worked_together'\n *    - relationship_source = 'experience_overlap'\n *    - confidence_score (0-100)\n * 3. Prevent duplicates by checking existing relationships\n */\n\nimport { supabase } from \"../db/supabaseClient\";\nimport { getExperienceForCandidate } from \"../domain/candidateExperience\";\nimport { getAllCandidates } from \"../domain/candidates\";\nimport { getAllHyperconnectors } from \"../domain/hyperconnectors\";\n\ninterface ExperienceRecord {\n  id: string;\n  candidate_id: string;\n  company_name: string | null;\n  start_date: string | null;\n  end_date: string | null;\n  role_title: string | null;\n  is_current?: boolean | null;\n}\n\ninterface OverlapResult {\n  hyperconnectorId: string;\n  candidateId: string;\n  companyName: string;\n  overlapMonths: number;\n  confidenceScore: number;\n  hciExperience: ExperienceRecord;\n  candidateExperience: ExperienceRecord;\n}\n\n/**\n * Normalizes company name for comparison\n * - Lowercase\n * - Trim whitespace\n * - Optionally strip common suffixes (S.A., Inc., LLC, etc.)\n */\nfunction normalizeCompanyName(companyName: string | null): string {\n  if (!companyName) return \"\";\n  \n  let normalized = companyName.toLowerCase().trim();\n  \n  // Remove common suffixes (optional, for better matching)\n  const suffixes = [\n    /\\s+s\\.a\\.$/i,\n    /\\s+s\\.a\\.\\s+de\\s+c\\.v\\.$/i,\n    /\\s+inc\\.?$/i,\n    /\\s+llc\\.?$/i,\n    /\\s+ltd\\.?$/i,\n    /\\s+corp\\.?$/i,\n  ];\n  \n  for (const suffix of suffixes) {\n    normalized = normalized.replace(suffix, \"\");\n  }\n  \n  return normalized.trim();\n}\n\n/**\n * Checks if two date ranges overlap\n * Treats NULL end_date as current date (or max date)\n */\nfunction dateRangesOverlap(\n  start1: string | null,\n  end1: string | null,\n  start2: string | null,\n  end2: string | null\n): { overlaps: boolean; overlapMonths: number } {\n  if (!start1 || !start2) {\n    return { overlaps: false, overlapMonths: 0 };\n  }\n\n  const now = new Date();\n  const maxDate = new Date(\"2099-12-31\"); // Far future date for NULL end_date\n\n  const date1Start = new Date(start1);\n  const date1End = end1 ? new Date(end1) : maxDate;\n  const date2Start = new Date(start2);\n  const date2End = end2 ? new Date(end2) : maxDate;\n\n  // Check if ranges overlap\n  const overlaps = date1Start <= date2End && date2Start <= date1End;\n\n  if (!overlaps) {\n    return { overlaps: false, overlapMonths: 0 };\n  }\n\n  // Calculate overlap duration\n  const overlapStart = date1Start > date2Start ? date1Start : date2Start;\n  const overlapEnd = date1End < date2End ? date1End : date2End;\n\n  // Calculate months of overlap\n  const monthsDiff =\n    (overlapEnd.getFullYear() - overlapStart.getFullYear()) * 12 +\n    (overlapEnd.getMonth() - overlapStart.getMonth());\n\n  // Add partial month if days are significant\n  const daysDiff = overlapEnd.getDate() - overlapStart.getDate();\n  const partialMonth = daysDiff > 15 ? 1 : daysDiff > 0 ? 0.5 : 0;\n\n  const overlapMonths = Math.max(0, monthsDiff + partialMonth);\n\n  return { overlaps: true, overlapMonths };\n}\n\n/**\n * Finds overlapping work experiences between a hyperconnector and a candidate\n * Returns the best overlap (highest confidence score)\n * \n * @param hyperconnectorId - The hyperconnector ID (needed for the result)\n * @param hciExperiences - Experience records for the hyperconnector (from their linked candidate profile)\n * @param candidateId - The candidate ID (needed for the result)\n * @param candidateExperiences - Experience records for the candidate\n */\nfunction findWorkOverlaps(\n  hyperconnectorId: string,\n  hciExperiences: ExperienceRecord[],\n  candidateId: string,\n  candidateExperiences: ExperienceRecord[]\n): OverlapResult | null {\n  let bestOverlap: OverlapResult | null = null;\n  let maxConfidence = 0;\n\n  for (const hciExp of hciExperiences) {\n    if (!hciExp.company_name) continue;\n\n    const normalizedHciCompany = normalizeCompanyName(hciExp.company_name);\n\n    for (const candidateExp of candidateExperiences) {\n      if (!candidateExp.company_name) continue;\n\n      const normalizedCandidateCompany = normalizeCompanyName(candidateExp.company_name);\n\n      // Check if same company (case-insensitive, normalized)\n      if (normalizedHciCompany !== normalizedCandidateCompany) continue;\n\n      // Check date overlap\n      const { overlaps, overlapMonths } = dateRangesOverlap(\n        hciExp.start_date,\n        hciExp.end_date,\n        candidateExp.start_date,\n        candidateExp.end_date\n      );\n\n      if (!overlaps) continue;\n\n      // Calculate confidence score\n      // Algorithm: Use overlap months, capped at 100\n      // If overlap is >= 12 months, score is 100\n      // Otherwise, score is (overlapMonths / 12) * 100, minimum 10\n      const confidenceScore = overlapMonths >= 12 \n        ? 100 \n        : Math.max(10, Math.min(100, Math.round((overlapMonths / 12) * 100)));\n\n      // Keep track of the best overlap (highest confidence)\n      if (confidenceScore > maxConfidence) {\n        maxConfidence = confidenceScore;\n        bestOverlap = {\n          hyperconnectorId,\n          candidateId,\n          companyName: hciExp.company_name,\n          overlapMonths,\n          confidenceScore,\n          hciExperience: hciExp,\n          candidateExperience: candidateExp,\n        };\n      }\n    }\n  }\n\n  return bestOverlap;\n}\n\n/**\n * Gets all candidates in a hyperconnector's network\n * This could be from candidate_connections or hyperconnector_candidates\n */\nasync function getCandidatesInHyperconnectorNetwork(\n  hyperconnectorId: string\n): Promise<string[]> {\n  // Try candidate_connections first (new table)\n  const { data: connections } = await supabase\n    .from(\"candidate_connections\")\n    .select(\"candidate_id\")\n    .eq(\"hyperconnector_id\", hyperconnectorId);\n\n  if (connections && connections.length > 0) {\n    return connections.map((c: any) => c.candidate_id);\n  }\n\n  // Fallback to hyperconnector_candidates\n  const { data: hciCandidates } = await supabase\n    .from(\"hyperconnector_candidates\")\n    .select(\"candidate_id\")\n    .eq(\"hyperconnector_id\", hyperconnectorId);\n\n  if (hciCandidates && hciCandidates.length > 0) {\n    return hciCandidates.map((c: any) => c.candidate_id);\n  }\n\n  return [];\n}\n\n/**\n * Gets the candidate_id for a hyperconnector\n * (Hyperconnectors might have a linked candidate profile)\n */\nasync function getHyperconnectorCandidateId(hyperconnectorId: string): Promise<string | null> {\n  // Check if hyperconnector has a candidate_id field or linked candidate\n  const { data: hci } = await supabase\n    .from(\"hyperconnectors\")\n    .select(\"candidate_id\")\n    .eq(\"id\", hyperconnectorId)\n    .maybeSingle();\n\n  return hci?.candidate_id || null;\n}\n\n/**\n * Checks if a relationship already exists\n * Checks both hyperconnector_candidates and candidate_connections\n */\nasync function relationshipExists(\n  hyperconnectorId: string,\n  candidateId: string,\n  relationshipType: string = \"worked_together\"\n): Promise<boolean> {\n  // Check in candidate_connections first (new table with source field)\n  const { data: connection, error: connError } = await supabase\n    .from(\"candidate_connections\")\n    .select(\"id\")\n    .eq(\"hyperconnector_id\", hyperconnectorId)\n    .eq(\"candidate_id\", candidateId)\n    .eq(\"source\", \"experience_overlap\")\n    .maybeSingle();\n\n  if (connError && connError.code !== \"PGRST116\") {\n    console.warn(\"Error checking candidate_connections:\", connError.message);\n  }\n\n  if (connection) return true;\n\n  // Fallback: check in hyperconnector_candidates\n  const { data: hciCandidate, error: hciError } = await supabase\n    .from(\"hyperconnector_candidates\")\n    .select(\"id\")\n    .eq(\"hyperconnector_id\", hyperconnectorId)\n    .eq(\"candidate_id\", candidateId)\n    .maybeSingle();\n\n  if (hciError && hciError.code !== \"PGRST116\") {\n    console.warn(\"Error checking hyperconnector_candidates:\", hciError.message);\n  }\n\n  return !!hciCandidate;\n}\n\n/**\n * Creates or updates a relationship\n * Uses candidate_connections for the new relationship with source and connection_strength\n * Also updates hyperconnector_candidates for backward compatibility\n */\nasync function createOrUpdateRelationship(\n  hyperconnectorId: string,\n  candidateId: string,\n  overlap: OverlapResult\n): Promise<void> {\n  const now = new Date().toISOString();\n\n  // 1. Insert/update in candidate_connections (new table with source and connection_strength)\n  try {\n    const { error: connError } = await supabase\n      .from(\"candidate_connections\")\n      .upsert(\n        {\n          hyperconnector_id: hyperconnectorId,\n          candidate_id: candidateId,\n          source: \"experience_overlap\",\n          connection_strength: overlap.confidenceScore,\n          created_at: now,\n          updated_at: now,\n        },\n        {\n          onConflict: \"hyperconnector_id,candidate_id\",\n        }\n      );\n\n    if (connError) {\n      console.warn(\"‚ö†Ô∏è Could not insert into candidate_connections:\", connError.message);\n      console.warn(\"   Error details:\", JSON.stringify(connError, null, 2));\n      // Continue to try hyperconnector_candidates\n    } else {\n      console.log(`   üìù Created/updated candidate_connection with strength ${overlap.confidenceScore}`);\n    }\n  } catch (error: any) {\n    console.warn(\"‚ö†Ô∏è Error with candidate_connections:\", error.message);\n    console.warn(\"   Stack:\", error.stack);\n  }\n\n  // 2. Also insert/update in hyperconnector_candidates for backward compatibility\n  try {\n    // First check if record exists\n    const { data: existing, error: checkError } = await supabase\n      .from(\"hyperconnector_candidates\")\n      .select(\"id\")\n      .eq(\"hyperconnector_id\", hyperconnectorId)\n      .eq(\"candidate_id\", candidateId)\n      .maybeSingle();\n\n    if (checkError && checkError.code !== \"PGRST116\") {\n      console.warn(\"‚ö†Ô∏è Error checking existing hyperconnector_candidates:\", checkError.message);\n    }\n\n    if (existing) {\n      // Update existing record\n      const { data: updated, error: updateError } = await supabase\n        .from(\"hyperconnector_candidates\")\n        .update({\n          relationship_type: \"worked_together\",\n          relationship_source: \"automatic_match\",\n        })\n        .eq(\"id\", existing.id)\n        .select();\n\n      if (updateError) {\n        console.error(\"‚ùå Error updating hyperconnector_candidates:\", updateError.message);\n        console.error(\"   Error details:\", JSON.stringify(updateError, null, 2));\n        console.error(\"   Hyperconnector ID:\", hyperconnectorId);\n        console.error(\"   Candidate ID:\", candidateId);\n      } else {\n        console.log(`   üìù Updated hyperconnector_candidates record (ID: ${existing.id})`);\n      }\n    } else {\n      // Insert new record\n      const { data: inserted, error: insertError } = await supabase\n        .from(\"hyperconnector_candidates\")\n        .insert({\n          hyperconnector_id: hyperconnectorId,\n          candidate_id: candidateId,\n          relationship_type: \"worked_together\",\n          relationship_source: \"automatic_match\",\n        })\n        .select();\n\n      if (insertError) {\n        console.error(\"‚ùå Error inserting into hyperconnector_candidates:\", insertError.message);\n        console.error(\"   Error details:\", JSON.stringify(insertError, null, 2));\n        console.error(\"   Hyperconnector ID:\", hyperconnectorId);\n        console.error(\"   Candidate ID:\", candidateId);\n        console.error(\"   Error code:\", insertError.code);\n        console.error(\"   Error hint:\", insertError.hint);\n      } else {\n        console.log(`   üìù Created new hyperconnector_candidates record (ID: ${inserted?.[0]?.id})`);\n      }\n    }\n  } catch (error: any) {\n    console.error(\"‚ùå Exception in hyperconnector_candidates operation:\", error.message);\n    console.error(\"   Stack:\", error.stack);\n  }\n}\n\n/**\n * Main function: Syncs relationships for a specific candidate\n * When a new candidate is created, check against all hyperconnectors\n */\nexport async function syncHyperconnectorCandidateRelationshipsForCandidate(\n  candidateId: string\n): Promise<void> {\n  console.log(`üîÑ Syncing relationships for candidate: ${candidateId}`);\n\n  // Get candidate's experience\n  const candidateExperiences = await getExperienceForCandidate(candidateId);\n  if (candidateExperiences.length === 0) {\n    console.log(`   ‚ö†Ô∏è No experience found for candidate ${candidateId}`);\n    return;\n  }\n\n  // Get all hyperconnectors\n  const hyperconnectors = await getAllHyperconnectors();\n  if (hyperconnectors.length === 0) {\n    console.log(\"   ‚ö†Ô∏è No hyperconnectors found\");\n    return;\n  }\n\n  const relationshipsCreated: OverlapResult[] = [];\n\n  // For each hyperconnector, check if they worked together\n  for (const hci of hyperconnectors) {\n    // Get hyperconnector's candidate_id (if they have a linked candidate profile)\n    const hciCandidateId = await getHyperconnectorCandidateId(hci.id);\n    \n    if (!hciCandidateId) {\n      // If hyperconnector doesn't have a candidate_id, skip\n      // (We need experience data to compare)\n      continue;\n    }\n\n    // Get hyperconnector's experience\n    const hciExperiences = await getExperienceForCandidate(hciCandidateId);\n    if (hciExperiences.length === 0) continue;\n\n    // Find overlaps\n    const overlap = findWorkOverlaps(hci.id, hciExperiences, candidateId, candidateExperiences);\n\n    if (overlap) {\n      // Check if relationship already exists\n      const exists = await relationshipExists(hci.id, candidateId);\n      \n      if (!exists) {\n        await createOrUpdateRelationship(hci.id, candidateId, overlap);\n        relationshipsCreated.push(overlap);\n        console.log(\n          `   ‚úÖ Found overlap: ${hci.full_name} ‚Üî candidate ${candidateId} at ${overlap.companyName} (${overlap.overlapMonths.toFixed(1)} months)`\n        );\n      } else {\n        console.log(\n          `   ‚è≠Ô∏è  Relationship already exists: ${hci.full_name} ‚Üî candidate ${candidateId}`\n        );\n      }\n    }\n  }\n\n  console.log(`‚úÖ Sync complete: ${relationshipsCreated.length} new relationships created`);\n}\n\n/**\n * Main function: Syncs relationships for a specific hyperconnector\n * Checks candidates in candidate_connections that are not yet in hyperconnector_candidates\n * If there's work overlap, creates record in hyperconnector_candidates\n */\nexport async function syncHyperconnectorCandidateRelationshipsForHyperconnector(\n  hyperconnectorId: string\n): Promise<void> {\n  console.log(`üîÑ Syncing relationships for hyperconnector: ${hyperconnectorId}`);\n\n  // Get hyperconnector's candidate_id\n  const hciCandidateId = await getHyperconnectorCandidateId(hyperconnectorId);\n  if (!hciCandidateId) {\n    console.log(`   ‚ö†Ô∏è Hyperconnector ${hyperconnectorId} has no linked candidate profile`);\n    return;\n  }\n\n  // Get hyperconnector's experience\n  const hciExperiences = await getExperienceForCandidate(hciCandidateId);\n  if (hciExperiences.length === 0) {\n    console.log(`   ‚ö†Ô∏è No experience found for hyperconnector ${hyperconnectorId}`);\n    return;\n  }\n\n  // Get candidates in hyperconnector's network from candidate_connections\n  const { data: connections, error: connError } = await supabase\n    .from(\"candidate_connections\")\n    .select(\"candidate_id\")\n    .eq(\"hyperconnector_id\", hyperconnectorId);\n\n  if (connError) {\n    console.error(`   ‚ùå Error fetching candidate_connections: ${connError.message}`);\n    return;\n  }\n\n  if (!connections || connections.length === 0) {\n    console.log(`   ‚ÑπÔ∏è  No candidates found in candidate_connections for this hyperconnector`);\n    return;\n  }\n\n  const candidateIds = connections.map((c: any) => c.candidate_id);\n  console.log(`   üìã Found ${candidateIds.length} candidate(s) in network`);\n\n  // Get candidates already in hyperconnector_candidates\n  const { data: existingRelations, error: existingError } = await supabase\n    .from(\"hyperconnector_candidates\")\n    .select(\"candidate_id\")\n    .eq(\"hyperconnector_id\", hyperconnectorId);\n\n  if (existingError) {\n    console.warn(`   ‚ö†Ô∏è Error checking existing relationships: ${existingError.message}`);\n  }\n\n  const existingCandidateIds = new Set(\n    (existingRelations || []).map((r: any) => r.candidate_id)\n  );\n\n  // Filter to only candidates NOT in hyperconnector_candidates\n  const candidatesToCheck = candidateIds.filter(\n    (candidateId: string) => !existingCandidateIds.has(candidateId) && candidateId !== hciCandidateId\n  );\n\n  if (candidatesToCheck.length === 0) {\n    console.log(`   ‚úÖ All candidates in network already have relationships in hyperconnector_candidates`);\n    return;\n  }\n\n  console.log(`   üîç Checking ${candidatesToCheck.length} candidate(s) without existing relationships`);\n\n  const relationshipsCreated: OverlapResult[] = [];\n\n  // For each candidate, check if they worked together\n  for (const candidateId of candidatesToCheck) {\n    const candidateExperiences = await getExperienceForCandidate(candidateId);\n    if (candidateExperiences.length === 0) {\n      console.log(`   ‚è≠Ô∏è  Skipping candidate ${candidateId}: no experience found`);\n      continue;\n    }\n\n    // Find overlaps\n    const overlap = findWorkOverlaps(hyperconnectorId, hciExperiences, candidateId, candidateExperiences);\n\n    if (overlap) {\n      // Create relationship in hyperconnector_candidates only\n      try {\n        const { data: inserted, error: insertError } = await supabase\n          .from(\"hyperconnector_candidates\")\n          .insert({\n            hyperconnector_id: hyperconnectorId,\n            candidate_id: candidateId,\n            relationship_type: \"worked_together\",\n            relationship_source: \"automatic_match\",\n          })\n          .select();\n\n        if (insertError) {\n          console.error(`   ‚ùå Error inserting for candidate ${candidateId}: ${insertError.message}`);\n          console.error(`   Error details:`, JSON.stringify(insertError, null, 2));\n        } else {\n          relationshipsCreated.push(overlap);\n          console.log(\n            `   ‚úÖ Created relationship: candidate ${candidateId} at ${overlap.companyName} (${overlap.overlapMonths.toFixed(1)} months)`\n          );\n        }\n      } catch (error: any) {\n        console.error(`   ‚ùå Exception inserting for candidate ${candidateId}: ${error.message}`);\n      }\n    } else {\n      console.log(`   ‚è≠Ô∏è  No overlap found for candidate ${candidateId}`);\n    }\n  }\n\n  console.log(`‚úÖ Sync complete: ${relationshipsCreated.length} new relationships created in hyperconnector_candidates`);\n}\n\n"],"names":[],"mappings":"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"}}]
}