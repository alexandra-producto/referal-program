{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/db/supabaseClient.ts"],"sourcesContent":["import { resolve } from \"path\";\nimport dotenv from \"dotenv\";\nimport { createClient } from \"@supabase/supabase-js\";\n\n// Carga .env.local desde la ra√≠z del proyecto\ndotenv.config({ path: resolve(process.cwd(), \".env.local\") });\n\nconst url = process.env.SUPABASE_URL;\nconst key = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!url || !key) {\n  console.error(\"SUPABASE_URL:\", url);\n  console.error(\"SUPABASE_SERVICE_ROLE_KEY:\", key);\n  throw new Error(\"‚ùå Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY.\");\n}\n\nexport const supabase = createClient(url, key);\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,8CAA8C;AAC9C,kKAAM,CAAC,MAAM,CAAC;IAAE,MAAM,IAAA,4GAAO,EAAC,QAAQ,GAAG,IAAI;AAAc;AAE3D,MAAM,MAAM,QAAQ,GAAG,CAAC,YAAY;AACpC,MAAM,MAAM,QAAQ,GAAG,CAAC,yBAAyB;AAEjD,IAAI,CAAC,OAAO,CAAC,KAAK;IAChB,QAAQ,KAAK,CAAC,iBAAiB;IAC/B,QAAQ,KAAK,CAAC,8BAA8B;IAC5C,MAAM,IAAI,MAAM;AAClB;AAEO,MAAM,WAAW,IAAA,yNAAY,EAAC,KAAK"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/utils/recommendationTokens.ts"],"sourcesContent":["import crypto from \"crypto\";\nimport { resolve } from \"path\";\nimport dotenv from \"dotenv\";\n\n// Cargar variables de entorno si no est√°n ya cargadas\nif (!process.env.RECOMMENDATION_SECRET) {\n  dotenv.config({ path: resolve(process.cwd(), \".env.local\") });\n}\n\n/**\n * Genera un token √∫nico y seguro para un link de recomendaci√≥n\n * El token contiene informaci√≥n codificada sobre el HCI y el Job\n */\nexport function generateRecommendationToken(\n  hyperconnectorId: string,\n  jobId: string\n): string {\n  // Crear un payload simple\n  const payload = `${hyperconnectorId}:${jobId}:${Date.now()}`;\n  \n  // Generar un hash √∫nico usando SHA256\n  const secret = process.env.RECOMMENDATION_SECRET || \"default-secret\";\n  const hash = crypto\n    .createHash(\"sha256\")\n    .update(payload + secret)\n    .digest(\"hex\");\n  \n  // Tomar los primeros 32 caracteres para un token m√°s corto\n  const token = hash.substring(0, 32);\n  \n  // Codificar el payload en base64url para poder decodificarlo despu√©s\n  const encodedPayload = Buffer.from(payload).toString(\"base64url\");\n  \n  // Combinar: token + payload codificado (separados por punto)\n  return `${token}.${encodedPayload}`;\n}\n\n/**\n * Valida y decodifica un token de recomendaci√≥n\n * Retorna null si el token es inv√°lido\n */\nexport function validateRecommendationToken(\n  token: string\n): { hyperconnectorId: string; jobId: string; timestamp: number } | null {\n  try {\n    const parts = token.split(\".\");\n    if (parts.length !== 2) return null;\n    \n    const [hashPart, encodedPayload] = parts;\n    \n    // Decodificar el payload\n    const payload = Buffer.from(encodedPayload, \"base64url\").toString(\"utf-8\");\n    const [hyperconnectorId, jobId, timestampStr] = payload.split(\":\");\n    \n    if (!hyperconnectorId || !jobId || !timestampStr) return null;\n    \n    // Validar el hash\n    const secret = process.env.RECOMMENDATION_SECRET || \"default-secret\";\n    const expectedHash = crypto\n      .createHash(\"sha256\")\n      .update(payload + secret)\n      .digest(\"hex\")\n      .substring(0, 32);\n    \n    if (hashPart !== expectedHash) {\n      console.warn(\"‚ùå Hash mismatch:\", {\n        received: hashPart,\n        expected: expectedHash.substring(0, 10) + \"...\",\n        secretLength: secret.length,\n        payload: payload.substring(0, 50) + \"...\"\n      });\n      return null;\n    }\n    \n    // Verificar que el token no sea muy viejo (opcional: 30 d√≠as)\n    const timestamp = parseInt(timestampStr, 10);\n    const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 d√≠as en ms\n    if (Date.now() - timestamp > maxAge) return null;\n    \n    return {\n      hyperconnectorId,\n      jobId,\n      timestamp,\n    };\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Normaliza la URL base para asegurar que localhost use http://\n */\nfunction normalizeBaseUrl(url: string): string {\n  if (!url) return \"http://localhost:3000\";\n  \n  // Si es localhost, forzar http://\n  if (url.includes(\"localhost\") || url.includes(\"127.0.0.1\")) {\n    return url.replace(/^https?:\\/\\//, \"http://\");\n  }\n  \n  // Para otras URLs, mantener el protocolo original o usar https:// por defecto\n  if (!url.match(/^https?:\\/\\//)) {\n    return `https://${url}`;\n  }\n  \n  return url;\n}\n\n/**\n * Genera la URL completa de recomendaci√≥n\n */\nexport function generateRecommendationUrl(\n  hyperconnectorId: string,\n  jobId: string,\n  baseUrl: string = process.env.APP_URL || \"http://localhost:3000\"\n): string {\n  const normalizedUrl = normalizeBaseUrl(baseUrl);\n  const token = generateRecommendationToken(hyperconnectorId, jobId);\n  // Asegurar que no haya doble slash\n  const cleanUrl = normalizedUrl.replace(/\\/$/, \"\");\n  return `${cleanUrl}/recommend/${token}`;\n}\n\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAEA,sDAAsD;AACtD,IAAI,CAAC,QAAQ,GAAG,CAAC,qBAAqB,EAAE;IACtC,kKAAM,CAAC,MAAM,CAAC;QAAE,MAAM,IAAA,4GAAO,EAAC,QAAQ,GAAG,IAAI;IAAc;AAC7D;AAMO,SAAS,4BACd,gBAAwB,EACxB,KAAa;IAEb,0BAA0B;IAC1B,MAAM,UAAU,GAAG,iBAAiB,CAAC,EAAE,MAAM,CAAC,EAAE,KAAK,GAAG,IAAI;IAE5D,sCAAsC;IACtC,MAAM,SAAS,QAAQ,GAAG,CAAC,qBAAqB,IAAI;IACpD,MAAM,OAAO,gHAAM,CAChB,UAAU,CAAC,UACX,MAAM,CAAC,UAAU,QACjB,MAAM,CAAC;IAEV,2DAA2D;IAC3D,MAAM,QAAQ,KAAK,SAAS,CAAC,GAAG;IAEhC,qEAAqE;IACrE,MAAM,iBAAiB,OAAO,IAAI,CAAC,SAAS,QAAQ,CAAC;IAErD,6DAA6D;IAC7D,OAAO,GAAG,MAAM,CAAC,EAAE,gBAAgB;AACrC;AAMO,SAAS,4BACd,KAAa;IAEb,IAAI;QACF,MAAM,QAAQ,MAAM,KAAK,CAAC;QAC1B,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;QAE/B,MAAM,CAAC,UAAU,eAAe,GAAG;QAEnC,yBAAyB;QACzB,MAAM,UAAU,OAAO,IAAI,CAAC,gBAAgB,aAAa,QAAQ,CAAC;QAClE,MAAM,CAAC,kBAAkB,OAAO,aAAa,GAAG,QAAQ,KAAK,CAAC;QAE9D,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,cAAc,OAAO;QAEzD,kBAAkB;QAClB,MAAM,SAAS,QAAQ,GAAG,CAAC,qBAAqB,IAAI;QACpD,MAAM,eAAe,gHAAM,CACxB,UAAU,CAAC,UACX,MAAM,CAAC,UAAU,QACjB,MAAM,CAAC,OACP,SAAS,CAAC,GAAG;QAEhB,IAAI,aAAa,cAAc;YAC7B,QAAQ,IAAI,CAAC,oBAAoB;gBAC/B,UAAU;gBACV,UAAU,aAAa,SAAS,CAAC,GAAG,MAAM;gBAC1C,cAAc,OAAO,MAAM;gBAC3B,SAAS,QAAQ,SAAS,CAAC,GAAG,MAAM;YACtC;YACA,OAAO;QACT;QAEA,8DAA8D;QAC9D,MAAM,YAAY,SAAS,cAAc;QACzC,MAAM,SAAS,KAAK,KAAK,KAAK,KAAK,MAAM,gBAAgB;QACzD,IAAI,KAAK,GAAG,KAAK,YAAY,QAAQ,OAAO;QAE5C,OAAO;YACL;YACA;YACA;QACF;IACF,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAEA;;CAEC,GACD,SAAS,iBAAiB,GAAW;IACnC,IAAI,CAAC,KAAK,OAAO;IAEjB,kCAAkC;IAClC,IAAI,IAAI,QAAQ,CAAC,gBAAgB,IAAI,QAAQ,CAAC,cAAc;QAC1D,OAAO,IAAI,OAAO,CAAC,gBAAgB;IACrC;IAEA,8EAA8E;IAC9E,IAAI,CAAC,IAAI,KAAK,CAAC,iBAAiB;QAC9B,OAAO,CAAC,QAAQ,EAAE,KAAK;IACzB;IAEA,OAAO;AACT;AAKO,SAAS,0BACd,gBAAwB,EACxB,KAAa,EACb,UAAkB,QAAQ,GAAG,CAAC,OAAO,IAAI,uBAAuB;IAEhE,MAAM,gBAAgB,iBAAiB;IACvC,MAAM,QAAQ,4BAA4B,kBAAkB;IAC5D,mCAAmC;IACnC,MAAM,WAAW,cAAc,OAAO,CAAC,OAAO;IAC9C,OAAO,GAAG,SAAS,WAAW,EAAE,OAAO;AACzC"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/recommendationLinks.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\nimport { generateRecommendationToken, validateRecommendationToken } from \"../utils/recommendationTokens\";\nimport { resolve } from \"path\";\nimport dotenv from \"dotenv\";\n\n// Asegurar que las variables de entorno est√©n cargadas\nif (!process.env.RECOMMENDATION_SECRET) {\n  dotenv.config({ path: resolve(process.cwd(), \".env.local\") });\n}\n\n/**\n * Crea un registro de link de recomendaci√≥n en la base de datos\n * Esto nos permite trackear qu√© links se han enviado y cu√°ndo\n */\nexport async function createRecommendationLink(\n  hyperconnectorId: string,\n  jobId: string\n) {\n  const token = generateRecommendationToken(hyperconnectorId, jobId);\n  \n  const { data, error } = await supabase\n    .from(\"recommendation_links\")\n    .insert({\n      hyperconnector_id: hyperconnectorId,\n      job_id: jobId,\n      token: token,\n      created_at: new Date().toISOString(),\n      expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 d√≠as\n    })\n    .select()\n    .single();\n\n  if (error) {\n    // Si la tabla no existe, retornamos solo el token (modo fallback)\n    console.warn(\"‚ö†Ô∏è recommendation_links table might not exist:\", error.message);\n    return { token };\n  }\n\n  return data;\n}\n\n/**\n * Valida un token y retorna la informaci√≥n del link\n */\nexport async function validateRecommendationLink(token: string) {\n  // Primero validar el token criptogr√°ficamente\n  const decoded = validateRecommendationToken(token);\n  if (!decoded) return null;\n\n  // Luego verificar en la BD (si la tabla existe)\n  const { data, error } = await supabase\n    .from(\"recommendation_links\")\n    .select(\"*\")\n    .eq(\"token\", token)\n    .single();\n\n  if (error) {\n    // Si la tabla no existe, confiar solo en la validaci√≥n criptogr√°fica\n    console.warn(\"‚ö†Ô∏è recommendation_links table might not exist:\", error.message);\n    return decoded;\n  }\n\n  if (!data) return null;\n\n  // Verificar que no haya expirado\n  if (new Date(data.expires_at) < new Date()) {\n    return null;\n  }\n\n  return {\n    hyperconnectorId: data.hyperconnector_id,\n    jobId: data.job_id,\n    timestamp: decoded.timestamp,\n  };\n}\n\n/**\n * Marca un link como usado (opcional, para analytics)\n */\nexport async function markRecommendationLinkAsUsed(token: string) {\n  const { error } = await supabase\n    .from(\"recommendation_links\")\n    .update({ used_at: new Date().toISOString() })\n    .eq(\"token\", token);\n\n  if (error) {\n    console.warn(\"‚ö†Ô∏è Could not mark link as used:\", error.message);\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,uDAAuD;AACvD,IAAI,CAAC,QAAQ,GAAG,CAAC,qBAAqB,EAAE;IACtC,kKAAM,CAAC,MAAM,CAAC;QAAE,MAAM,IAAA,4GAAO,EAAC,QAAQ,GAAG,IAAI;IAAc;AAC7D;AAMO,eAAe,yBACpB,gBAAwB,EACxB,KAAa;IAEb,MAAM,QAAQ,IAAA,qLAA2B,EAAC,kBAAkB;IAE5D,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,wBACL,MAAM,CAAC;QACN,mBAAmB;QACnB,QAAQ;QACR,OAAO;QACP,YAAY,IAAI,OAAO,WAAW;QAClC,YAAY,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,MAAM,WAAW;IACzE,GACC,MAAM,GACN,MAAM;IAET,IAAI,OAAO;QACT,kEAAkE;QAClE,QAAQ,IAAI,CAAC,kDAAkD,MAAM,OAAO;QAC5E,OAAO;YAAE;QAAM;IACjB;IAEA,OAAO;AACT;AAKO,eAAe,2BAA2B,KAAa;IAC5D,8CAA8C;IAC9C,MAAM,UAAU,IAAA,qLAA2B,EAAC;IAC5C,IAAI,CAAC,SAAS,OAAO;IAErB,gDAAgD;IAChD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,wBACL,MAAM,CAAC,KACP,EAAE,CAAC,SAAS,OACZ,MAAM;IAET,IAAI,OAAO;QACT,qEAAqE;QACrE,QAAQ,IAAI,CAAC,kDAAkD,MAAM,OAAO;QAC5E,OAAO;IACT;IAEA,IAAI,CAAC,MAAM,OAAO;IAElB,iCAAiC;IACjC,IAAI,IAAI,KAAK,KAAK,UAAU,IAAI,IAAI,QAAQ;QAC1C,OAAO;IACT;IAEA,OAAO;QACL,kBAAkB,KAAK,iBAAiB;QACxC,OAAO,KAAK,MAAM;QAClB,WAAW,QAAQ,SAAS;IAC9B;AACF;AAKO,eAAe,6BAA6B,KAAa;IAC9D,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAC7B,IAAI,CAAC,wBACL,MAAM,CAAC;QAAE,SAAS,IAAI,OAAO,WAAW;IAAG,GAC3C,EAAE,CAAC,SAAS;IAEf,IAAI,OAAO;QACT,QAAQ,IAAI,CAAC,mCAAmC,MAAM,OAAO;IAC/D;AACF"}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/jobs.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getJobById(id: string) {\n  const { data, error } = await supabase\n    .from(\"jobs\")\n    .select(\"*\")\n    .eq(\"id\", id)\n    .maybeSingle();\n\n  if (error) throw new Error(error.message);\n  return data;\n}\n\n// Para este test: buscar el rol de Vemo por nombre de empresa\nexport async function getJobByCompanyNameLike(company: string) {\n  const { data, error } = await supabase\n    .from(\"jobs\")\n    .select(\"*\")\n    .ilike(\"company_name\", `%${company}%`)\n    .limit(1)\n    .maybeSingle();\n\n  if (error) throw new Error(error.message);\n  return data;\n}\n\n/**\n * Creates a new job and optionally triggers matching with all candidates\n */\nexport async function createJob(\n  job: any,\n  options?: { triggerMatching?: boolean }\n) {\n  const { data, error } = await supabase\n    .from(\"jobs\")\n    .insert(job)\n    .select()\n    .single();\n\n  if (error) throw new Error(error.message);\n\n  // Trigger matching if requested (non-blocking)\n  if (options?.triggerMatching && data?.id) {\n    // Run asynchronously to not block the insert\n    import(\"../agents/matchJobCandidate\")\n      .then(({ matchJobWithAllCandidates }) => {\n        matchJobWithAllCandidates(data.id).catch((err) => {\n          console.error(\"Error in background matching after job creation:\", err);\n        });\n      })\n      .catch((err) => {\n        console.error(\"Error loading matching module:\", err);\n      });\n  }\n\n  return data;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,eAAe,WAAW,EAAU;IACzC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,QACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,IACT,WAAW;IAEd,IAAI,OAAO,MAAM,IAAI,MAAM,MAAM,OAAO;IACxC,OAAO;AACT;AAGO,eAAe,wBAAwB,OAAe;IAC3D,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,QACL,MAAM,CAAC,KACP,KAAK,CAAC,gBAAgB,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EACpC,KAAK,CAAC,GACN,WAAW;IAEd,IAAI,OAAO,MAAM,IAAI,MAAM,MAAM,OAAO;IACxC,OAAO;AACT;AAKO,eAAe,UACpB,GAAQ,EACR,OAAuC;IAEvC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,QACL,MAAM,CAAC,KACP,MAAM,GACN,MAAM;IAET,IAAI,OAAO,MAAM,IAAI,MAAM,MAAM,OAAO;IAExC,+CAA+C;IAC/C,IAAI,SAAS,mBAAmB,MAAM,IAAI;QACxC,6CAA6C;QAC7C,wHACG,IAAI,CAAC,CAAC,EAAE,yBAAyB,EAAE;YAClC,0BAA0B,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC;gBACxC,QAAQ,KAAK,CAAC,oDAAoD;YACpE;QACF,GACC,KAAK,CAAC,CAAC;YACN,QAAQ,KAAK,CAAC,kCAAkC;QAClD;IACJ;IAEA,OAAO;AACT"}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/hyperconnectors.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getAllHyperconnectors() {\n  const { data, error } = await supabase.from(\"hyperconnectors\").select(\"*\");\n  if (error) throw error;\n  return data;\n}\n\nexport async function getHyperconnectorById(id: string) {\n  const { data, error } = await supabase.from(\"hyperconnectors\").select(\"*\").eq(\"id\", id).single();\n  if (error) throw error;\n  return data;\n}\n\nexport async function createHyperconnector(hci: any) {\n  const { data, error } = await supabase.from(\"hyperconnectors\").insert(hci).select().single();\n  if (error) throw error;\n\n  // Trigger relationship sync (non-blocking)\n  if (data?.id) {\n    import(\"../agents/syncHyperconnectorRelationships\")\n      .then(({ syncHyperconnectorCandidateRelationshipsForHyperconnector }) => {\n        syncHyperconnectorCandidateRelationshipsForHyperconnector(data.id).catch((err) => {\n          console.error(\"Error in background relationship sync after hyperconnector creation:\", err);\n        });\n      })\n      .catch((err) => {\n        console.error(\"Error loading relationship sync module:\", err);\n      });\n  }\n\n  return data;\n}\n\nexport async function updateHyperconnector(id: string, updates: any) {\n  const { data, error } = await supabase.from(\"hyperconnectors\").update(updates).eq(\"id\", id).select().single();\n  if (error) throw error;\n  return data;\n}\n\nexport async function deleteHyperconnector(id: string) {\n  const { error } = await supabase.from(\"hyperconnectors\").delete().eq(\"id\", id);\n  if (error) throw error;\n  return true;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAEO,eAAe;IACpB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC;IACtE,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,sBAAsB,EAAU;IACpD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC,KAAK,EAAE,CAAC,MAAM,IAAI,MAAM;IAC9F,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,qBAAqB,GAAQ;IACjD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC,KAAK,MAAM,GAAG,MAAM;IAC1F,IAAI,OAAO,MAAM;IAEjB,2CAA2C;IAC3C,IAAI,MAAM,IAAI;QACZ,sIACG,IAAI,CAAC,CAAC,EAAE,yDAAyD,EAAE;YAClE,0DAA0D,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC;gBACxE,QAAQ,KAAK,CAAC,wEAAwE;YACxF;QACF,GACC,KAAK,CAAC,CAAC;YACN,QAAQ,KAAK,CAAC,2CAA2C;QAC3D;IACJ;IAEA,OAAO;AACT;AAEO,eAAe,qBAAqB,EAAU,EAAE,OAAY;IACjE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC,SAAS,EAAE,CAAC,MAAM,IAAI,MAAM,GAAG,MAAM;IAC3G,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,qBAAqB,EAAU;IACnD,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,GAAG,EAAE,CAAC,MAAM;IAC3E,IAAI,OAAO,MAAM;IACjB,OAAO;AACT"}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/hyperconnectorCandidates.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getHyperconnectorByEmail(email: string) {\n  const { data, error } = await supabase\n    .from(\"hyperconnectors\")\n    .select(\"*\")\n    .eq(\"email\", email)\n    .maybeSingle();\n\n  if (error) throw new Error(error.message);\n  return data;\n}\n\n/**\n * Devuelve los candidatos que:\n *  - Est√°n matcheados con un job (job_candidate_matches)\n *  - Y tienen relaci√≥n con el hyperconnector (hyperconnector_candidates)\n */\nexport async function getRecommendableCandidatesForHyperconnector(\n  jobId: string,\n  hyperconnectorId: string\n) {\n  // 1) relaciones HCI ‚Üî candidatos\n  // Intentar obtener shared_experience si existe, sino solo candidate_id\n  let links: any[] = [];\n  let hasSharedExperience = false;\n\n  // Primero intentar con shared_experience\n  const { data: linksWithExp, error: expError } = await supabase\n    .from(\"hyperconnector_candidates\")\n    .select(\"candidate_id, shared_experience\")\n    .eq(\"hyperconnector_id\", hyperconnectorId);\n\n  if (!expError && linksWithExp) {\n    links = linksWithExp;\n    hasSharedExperience = true;\n  } else {\n    // Si falla, intentar solo con candidate_id\n    const { data: simpleLinks, error: simpleError } = await supabase\n      .from(\"hyperconnector_candidates\")\n      .select(\"candidate_id\")\n      .eq(\"hyperconnector_id\", hyperconnectorId);\n    \n    if (simpleError) throw new Error(simpleError.message);\n    if (!simpleLinks || simpleLinks.length === 0) return [];\n    \n    links = simpleLinks.map(l => ({ candidate_id: l.candidate_id, shared_experience: null }));\n  }\n\n  return processCandidates(links, jobId);\n}\n\nasync function processCandidates(links: any[], jobId: string) {\n  const candidateIds = links.map((l) => l.candidate_id);\n\n  // 2) matches job ‚Üî candidatos (opcional, si la tabla existe)\n  let matches: any[] = [];\n  try {\n    const { data: jobMatches, error: matchesError } = await supabase\n      .from(\"job_candidate_matches\")\n      .select(\"candidate_id, match_score\")\n      .eq(\"job_id\", jobId)\n      .in(\"candidate_id\", candidateIds);\n\n    if (!matchesError && jobMatches) {\n      matches = jobMatches;\n    }\n  } catch (error) {\n    // Si la tabla no existe, continuar sin matches\n    console.warn(\"‚ö†Ô∏è Tabla job_candidate_matches no encontrada, continuando sin matches\");\n  }\n\n  const matchByCandidateId = new Map(\n    matches.map((m) => [m.candidate_id, m.match_score])\n  );\n\n  // 3) info de candidatos (obtener m√°s campos para el dise√±o)\n  const { data: candidates, error: candidatesError } = await supabase\n    .from(\"candidates\")\n    .select(\"id, full_name, current_company, current_job_title, country, industry\")\n    .in(\"id\", candidateIds);\n\n  if (candidatesError) throw new Error(candidatesError.message);\n\n  // 4) combinamos todo\n  const linkByCandidateId = new Map(\n    links.map((l) => [l.candidate_id, l.shared_experience || null])\n  );\n\n  // IMPORTANTE: Solo devolver candidatos que est√°n TANTO en hyperconnector_candidates\n  // COMO en job_candidate_matches (intersecci√≥n de ambas tablas)\n  // Si no hay matches, no devolver ning√∫n candidato (requerimos match obligatorio)\n  const filteredCandidates = matches.length > 0\n    ? (candidates || []).filter((c) => matchByCandidateId.has(c.id))\n    : []; // No devolver candidatos si no hay matches\n\n  return filteredCandidates\n    .map((c) => ({\n      id: c.id,\n      full_name: c.full_name,\n      current_company: c.current_company,\n      current_job_title: c.current_job_title || null,\n      country: c.country || null,\n      industry: c.industry || null,\n      match_score: matchByCandidateId.get(c.id) || null,\n      shared_experience: linkByCandidateId.get(c.id) || null,\n    }))\n    .sort((a, b) => (b.match_score || 0) - (a.match_score || 0));\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/app/api/recommend/%5Btoken%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { resolve } from \"path\";\nimport dotenv from \"dotenv\";\nimport { validateRecommendationLink } from \"../../../../src/domain/recommendationLinks\";\nimport { getJobById } from \"../../../../src/domain/jobs\";\nimport { getHyperconnectorById } from \"../../../../src/domain/hyperconnectors\";\nimport { getRecommendableCandidatesForHyperconnector } from \"../../../../src/domain/hyperconnectorCandidates\";\n\n// Asegurar que las variables de entorno est√©n cargadas en Next.js\nif (!process.env.RECOMMENDATION_SECRET) {\n  dotenv.config({ path: resolve(process.cwd(), \".env.local\") });\n}\n\n/**\n * GET /api/recommend/[token]\n * Obtiene los datos del job y candidatos para un token de recomendaci√≥n\n */\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ token: string }> }\n) {\n  try {\n    const { token } = await params;\n\n    console.log(\"üîç Validando token:\", token.substring(0, 30) + \"...\");\n\n    // Validar el token\n    const linkData = await validateRecommendationLink(token);\n    if (!linkData) {\n      console.error(\"‚ùå Token inv√°lido o expirado\");\n      return NextResponse.json(\n        { error: \"Token inv√°lido o expirado\" },\n        { status: 401 }\n      );\n    }\n\n    console.log(\"‚úÖ Token v√°lido, linkData:\", linkData);\n\n    // linkData puede tener hyperconnectorId/jobId directamente o en propiedades diferentes\n    const hyperconnectorId = linkData.hyperconnectorId || (linkData as any).hyperconnector_id;\n    const jobId = linkData.jobId || (linkData as any).job_id;\n    \n    console.log(\"üìã IDs extra√≠dos - HCI:\", hyperconnectorId, \"Job:\", jobId);\n    \n    if (!hyperconnectorId || !jobId) {\n      console.error(\"‚ùå Faltan datos en el token\");\n      return NextResponse.json(\n        { error: \"Token inv√°lido: faltan datos\" },\n        { status: 401 }\n      );\n    }\n\n    // Obtener datos del job\n    console.log(\"üîç Buscando job:\", jobId);\n    const job = await getJobById(jobId);\n    if (!job) {\n      console.error(\"‚ùå Job no encontrado:\", jobId);\n      return NextResponse.json(\n        { error: \"Job no encontrado\" },\n        { status: 404 }\n      );\n    }\n    console.log(\"‚úÖ Job encontrado:\", job.role_title || job.company_name);\n\n    // Obtener datos del hyperconnector\n    console.log(\"üîç Buscando hyperconnector:\", hyperconnectorId);\n    const hci = await getHyperconnectorById(hyperconnectorId);\n    if (!hci) {\n      console.error(\"‚ùå Hyperconnector no encontrado:\", hyperconnectorId);\n      return NextResponse.json(\n        { error: \"Hyperconnector no encontrado\" },\n        { status: 404 }\n      );\n    }\n    console.log(\"‚úÖ Hyperconnector encontrado:\", hci.full_name);\n\n    // Obtener candidatos recomendables\n    const candidates = await getRecommendableCandidatesForHyperconnector(\n      jobId,\n      hyperconnectorId\n    );\n\n    // Obtener match scores de job_candidate_matches para cada candidato\n    const { supabase } = await import(\"../../../../src/db/supabaseClient\");\n    const candidateIds = candidates.map((c: any) => c.id);\n    \n    let matchScores: Map<string, number> = new Map();\n    if (candidateIds.length > 0) {\n      const { data: matches, error: matchesError } = await supabase\n        .from(\"job_candidate_matches\")\n        .select(\"candidate_id, match_score\")\n        .eq(\"job_id\", jobId)\n        .in(\"candidate_id\", candidateIds);\n\n      if (!matchesError && matches) {\n        matches.forEach((match: any) => {\n          matchScores.set(match.candidate_id, match.match_score);\n        });\n      }\n    }\n\n    // Agregar match_score a cada candidato\n    const candidatesWithMatch = candidates.map((candidate: any) => ({\n      ...candidate,\n      match_score: matchScores.get(candidate.id) || null,\n    }));\n\n    // Obtener informaci√≥n del owner candidate (quien postul√≥ el job)\n    let ownerCandidate = null;\n    if (job.owner_candidate_id) {\n      // Obtener informaci√≥n b√°sica del candidate\n      const { data: ownerData, error: ownerError } = await supabase\n        .from(\"candidates\")\n        .select(\"id, full_name, current_company, email\")\n        .eq(\"id\", job.owner_candidate_id)\n        .maybeSingle();\n      \n      if (!ownerError && ownerData) {\n        ownerCandidate = ownerData;\n        \n        // Intentar obtener el t√≠tulo/posici√≥n actual del candidate desde candidate_experience\n        const { data: experienceData } = await supabase\n          .from(\"candidate_experience\")\n          .select(\"title, company_name\")\n          .eq(\"candidate_id\", job.owner_candidate_id)\n          .eq(\"is_current\", true)\n          .order(\"start_date\", { ascending: false })\n          .limit(1)\n          .maybeSingle();\n        \n        if (experienceData) {\n          ownerCandidate.current_title = experienceData.title;\n          // Si no tiene current_company, usar el de experience\n          if (!ownerCandidate.current_company && experienceData.company_name) {\n            ownerCandidate.current_company = experienceData.company_name;\n          }\n        }\n      }\n    }\n\n    return NextResponse.json({\n      job: {\n        ...job,\n        owner_role: job.owner_role || null, // Incluir owner_role del job\n      },\n      hyperconnector: hci,\n      candidates: candidatesWithMatch,\n      ownerCandidate,\n      token,\n    });\n  } catch (error: any) {\n    console.error(\"‚ùå Error en GET /api/recommend/[token]:\", error);\n    console.error(\"Stack:\", error.stack);\n    return NextResponse.json(\n      { error: \"Error interno del servidor\", details: process.env.NODE_ENV === \"development\" ? error.message : undefined },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}