{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/utils/linkedinAuth.ts"],"sourcesContent":["// Funciones helper para obtener variables de entorno (lazy loading)\n// Next.js carga .env.local autom√°ticamente, pero verificamos que est√©n disponibles\nfunction getLinkedInClientId(): string {\n  const value = process.env.LINKEDIN_CLIENT_ID;\n  if (!value) {\n    console.error(\"‚ùå LINKEDIN_CLIENT_ID no encontrado en process.env\");\n    console.error(\"Variables disponibles:\", Object.keys(process.env).filter(k => k.includes(\"LINKEDIN\")));\n    throw new Error(\"LINKEDIN_CLIENT_ID no est√° configurado. Verifica que est√© en .env.local\");\n  }\n  return value;\n}\n\nfunction getLinkedInClientSecret(): string {\n  const value = process.env.LINKEDIN_CLIENT_SECRET;\n  if (!value) {\n    console.error(\"‚ùå LINKEDIN_CLIENT_SECRET no encontrado en process.env\");\n    throw new Error(\"LINKEDIN_CLIENT_SECRET no est√° configurado. Verifica que est√© en .env.local\");\n  }\n  return value;\n}\n\nfunction getLinkedInRedirectUri(): string {\n  const value = process.env.LINKEDIN_REDIRECT_URI;\n  if (!value) {\n    console.error(\"‚ùå LINKEDIN_REDIRECT_URI no encontrado en process.env\");\n    throw new Error(\"LINKEDIN_REDIRECT_URI no est√° configurado. Verifica que est√© en .env.local\");\n  }\n  return value;\n}\n\nexport interface LinkedInUserInfo {\n  sub: string; // LinkedIn ID\n  email?: string;\n  name?: string;\n  given_name?: string;\n  family_name?: string;\n  picture?: string;\n}\n\nexport interface LinkedInProfile {\n  id: string;\n  vanityName?: string;\n  localizedFirstName?: string;\n  localizedLastName?: string;\n  headline?: string;\n}\n\n/**\n * Genera la URL de autorizaci√≥n de LinkedIn\n */\nexport function getLinkedInAuthUrl(state: string, role: string): string {\n  const clientId = getLinkedInClientId();\n  const redirectUri = getLinkedInRedirectUri();\n\n  const params = new URLSearchParams({\n    response_type: \"code\",\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    scope: \"openid profile email\",\n    state: state,\n  });\n\n  return `https://www.linkedin.com/oauth/v2/authorization?${params.toString()}`;\n}\n\n/**\n * Intercambia el c√≥digo de autorizaci√≥n por un access token\n */\nexport async function exchangeCodeForToken(code: string): Promise<string> {\n  const clientId = getLinkedInClientId();\n  const clientSecret = getLinkedInClientSecret();\n  const redirectUri = getLinkedInRedirectUri();\n\n  const response = await fetch(\"https://www.linkedin.com/oauth/v2/accessToken\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    body: new URLSearchParams({\n      grant_type: \"authorization_code\",\n      code: code,\n      redirect_uri: redirectUri,\n      client_id: clientId,\n      client_secret: clientSecret,\n    }),\n  });\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Error obteniendo token: ${response.status} - ${errorText}`);\n  }\n\n  const data = await response.json();\n  return data.access_token;\n}\n\n/**\n * Obtiene informaci√≥n del usuario desde LinkedIn usando OpenID Connect\n */\nexport async function getUserInfo(accessToken: string): Promise<LinkedInUserInfo> {\n  const response = await fetch(\"https://api.linkedin.com/v2/userinfo\", {\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    },\n  });\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Error obteniendo userinfo: ${response.status} - ${errorText}`);\n  }\n\n  return await response.json();\n}\n\n/**\n * Obtiene perfil adicional del usuario (headline, vanityName)\n */\nexport async function getProfile(accessToken: string): Promise<LinkedInProfile | null> {\n  try {\n    const response = await fetch(\n      \"https://api.linkedin.com/v2/me?projection=(id,vanityName,localizedFirstName,localizedLastName,headline)\",\n      {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n        },\n      }\n    );\n\n    if (!response.ok) {\n      // Si falla, no es cr√≠tico, retornamos null\n      return null;\n    }\n\n    return await response.json();\n  } catch (error) {\n    console.warn(\"Error obteniendo perfil adicional de LinkedIn:\", error);\n    return null;\n  }\n}\n\n/**\n * Parsea el headline de LinkedIn para extraer current_role y current_company\n */\nexport function parseHeadline(headline?: string): {\n  current_role: string | null;\n  current_company: string | null;\n} {\n  if (!headline) {\n    return { current_role: null, current_company: null };\n  }\n\n  // Buscar patr√≥n \"Role at Company\"\n  const atMatch = headline.match(/^(.+?)\\s+at\\s+(.+)$/i);\n  if (atMatch) {\n    return {\n      current_role: atMatch[1].trim(),\n      current_company: atMatch[2].trim(),\n    };\n  }\n\n  return { current_role: null, current_company: null };\n}\n\n/**\n * Construye la URL de LinkedIn del usuario\n */\nexport function buildLinkedInUrl(vanityName?: string): string | null {\n  if (!vanityName) {\n    return null;\n  }\n  return `https://www.linkedin.com/in/${vanityName}`;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/db/supabaseClient.ts"],"sourcesContent":["import { resolve } from \"path\";\nimport dotenv from \"dotenv\";\nimport { createClient } from \"@supabase/supabase-js\";\n\n// Carga .env.local desde la ra√≠z del proyecto\ndotenv.config({ path: resolve(process.cwd(), \".env.local\") });\n\nconst url = process.env.SUPABASE_URL;\nconst key = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!url || !key) {\n  console.error(\"SUPABASE_URL:\", url);\n  console.error(\"SUPABASE_SERVICE_ROLE_KEY:\", key);\n  throw new Error(\"‚ùå Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY.\");\n}\n\nexport const supabase = createClient(url, key);\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,8CAA8C;AAC9C,kKAAM,CAAC,MAAM,CAAC;IAAE,MAAM,IAAA,4GAAO,EAAC,QAAQ,GAAG,IAAI;AAAc;AAE3D,MAAM,MAAM,QAAQ,GAAG,CAAC,YAAY;AACpC,MAAM,MAAM,QAAQ,GAAG,CAAC,yBAAyB;AAEjD,IAAI,CAAC,OAAO,CAAC,KAAK;IAChB,QAAQ,KAAK,CAAC,iBAAiB;IAC/B,QAAQ,KAAK,CAAC,8BAA8B;IAC5C,MAAM,IAAI,MAAM;AAClB;AAEO,MAAM,WAAW,IAAA,yNAAY,EAAC,KAAK"}},
    {"offset": {"line": 232, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/users.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport type UserRole = \"admin\" | \"hyperconnector\" | \"solicitante\";\n\nexport interface User {\n  id: string;\n  email: string;\n  full_name: string;\n  role: UserRole;\n  linkedin_id?: string | null;\n  linkedin_url?: string | null;\n  current_job_title?: string | null;\n  current_company?: string | null;\n  auth_provider?: string | null;\n  provider_user_id?: string | null;\n  last_login_at?: string | null;\n  created_at?: string;\n  updated_at?: string;\n}\n\n/**\n * Busca un usuario por LinkedIn ID o email\n */\nexport async function findUserByLinkedInOrEmail(\n  linkedinId?: string,\n  email?: string\n): Promise<User | null> {\n  if (!linkedinId && !email) {\n    return null;\n  }\n\n  let query = supabase.from(\"users\").select(\"*\");\n\n  if (linkedinId) {\n    query = query.eq(\"linkedin_id\", linkedinId);\n  } else if (email) {\n    query = query.eq(\"email\", email);\n  }\n\n  const { data, error } = await query.maybeSingle();\n\n  if (error && error.code !== \"PGRST116\") {\n    // PGRST116 = no rows returned\n    throw error;\n  }\n\n  return data || null;\n}\n\n/**\n * Crea un nuevo usuario\n */\nexport async function createUser(userData: Partial<User>): Promise<User> {\n  const { data, error } = await supabase\n    .from(\"users\")\n    .insert({\n      ...userData,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    })\n    .select()\n    .single();\n\n  if (error) throw error;\n  return data;\n}\n\n/**\n * Actualiza un usuario existente\n */\nexport async function updateUser(id: string, updates: Partial<User>): Promise<User> {\n  const { data, error } = await supabase\n    .from(\"users\")\n    .update({\n      ...updates,\n      updated_at: new Date().toISOString(),\n    })\n    .eq(\"id\", id)\n    .select()\n    .single();\n\n  if (error) throw error;\n  return data;\n}\n\n/**\n * Upsert: crea o actualiza un usuario\n */\nexport async function upsertUser(userData: Partial<User>): Promise<User> {\n  const existing = await findUserByLinkedInOrEmail(\n    userData.linkedin_id || undefined,\n    userData.email || undefined\n  );\n\n  if (existing) {\n    return await updateUser(existing.id, userData);\n  } else {\n    return await createUser(userData);\n  }\n}\n\n/**\n * Obtiene un usuario por ID\n */\nexport async function getUserById(id: string): Promise<User | null> {\n  const { data, error } = await supabase\n    .from(\"users\")\n    .select(\"*\")\n    .eq(\"id\", id)\n    .maybeSingle();\n\n  if (error) throw error;\n  return data;\n}\n\n/**\n * Actualiza el √∫ltimo login de un usuario\n */\nexport async function updateLastLogin(userId: string): Promise<void> {\n  await supabase\n    .from(\"users\")\n    .update({ last_login_at: new Date().toISOString() })\n    .eq(\"id\", userId);\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;AAuBO,eAAe,0BACpB,UAAmB,EACnB,KAAc;IAEd,IAAI,CAAC,cAAc,CAAC,OAAO;QACzB,OAAO;IACT;IAEA,IAAI,QAAQ,yJAAQ,CAAC,IAAI,CAAC,SAAS,MAAM,CAAC;IAE1C,IAAI,YAAY;QACd,QAAQ,MAAM,EAAE,CAAC,eAAe;IAClC,OAAO,IAAI,OAAO;QAChB,QAAQ,MAAM,EAAE,CAAC,SAAS;IAC5B;IAEA,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,MAAM,WAAW;IAE/C,IAAI,SAAS,MAAM,IAAI,KAAK,YAAY;QACtC,8BAA8B;QAC9B,MAAM;IACR;IAEA,OAAO,QAAQ;AACjB;AAKO,eAAe,WAAW,QAAuB;IACtD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,SACL,MAAM,CAAC;QACN,GAAG,QAAQ;QACX,YAAY,IAAI,OAAO,WAAW;QAClC,YAAY,IAAI,OAAO,WAAW;IACpC,GACC,MAAM,GACN,MAAM;IAET,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAKO,eAAe,WAAW,EAAU,EAAE,OAAsB;IACjE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,SACL,MAAM,CAAC;QACN,GAAG,OAAO;QACV,YAAY,IAAI,OAAO,WAAW;IACpC,GACC,EAAE,CAAC,MAAM,IACT,MAAM,GACN,MAAM;IAET,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAKO,eAAe,WAAW,QAAuB;IACtD,MAAM,WAAW,MAAM,0BACrB,SAAS,WAAW,IAAI,WACxB,SAAS,KAAK,IAAI;IAGpB,IAAI,UAAU;QACZ,OAAO,MAAM,WAAW,SAAS,EAAE,EAAE;IACvC,OAAO;QACL,OAAO,MAAM,WAAW;IAC1B;AACF;AAKO,eAAe,YAAY,EAAU;IAC1C,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,SACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,IACT,WAAW;IAEd,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAKO,eAAe,gBAAgB,MAAc;IAClD,MAAM,yJAAQ,CACX,IAAI,CAAC,SACL,MAAM,CAAC;QAAE,eAAe,IAAI,OAAO,WAAW;IAAG,GACjD,EAAE,CAAC,MAAM;AACd"}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/candidates.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getAllCandidates() {\n  const { data, error } = await supabase.from(\"candidates\").select(\"*\");\n  if (error) throw error;\n  return data;\n}\n\nexport async function getCandidateById(id: string) {\n  const { data, error } = await supabase.from(\"candidates\").select(\"*\").eq(\"id\", id).maybeSingle();\n  if (error) throw error;\n  return data;\n}\n\n/**\n * Creates a new candidate and optionally triggers matching with all jobs\n */\nexport async function createCandidate(\n  candidate: any,\n  options?: { triggerMatching?: boolean }\n) {\n  const { data, error } = await supabase\n    .from(\"candidates\")\n    .insert(candidate)\n    .select()\n    .single();\n  \n  if (error) throw error;\n\n  // Trigger matching if requested (non-blocking)\n  if (options?.triggerMatching && data?.id) {\n    // Run asynchronously to not block the insert\n    import(\"../agents/matchJobCandidate\")\n      .then(({ matchCandidateWithAllJobs }) => {\n        matchCandidateWithAllJobs(data.id).catch((err) => {\n          console.error(\"Error in background matching after candidate creation:\", err);\n        });\n      })\n      .catch((err) => {\n        console.error(\"Error loading matching module:\", err);\n      });\n  }\n\n  // Trigger relationship sync (non-blocking)\n  if (data?.id) {\n    import(\"../agents/syncHyperconnectorRelationships\")\n      .then(({ syncHyperconnectorCandidateRelationshipsForCandidate }) => {\n        syncHyperconnectorCandidateRelationshipsForCandidate(data.id).catch((err) => {\n          console.error(\"Error in background relationship sync after candidate creation:\", err);\n        });\n      })\n      .catch((err) => {\n        console.error(\"Error loading relationship sync module:\", err);\n      });\n  }\n\n  return data;\n}\n\nexport async function updateCandidate(id: string, updates: any) {\n  const { data, error } = await supabase.from(\"candidates\").update(updates).eq(\"id\", id).select().single();\n  if (error) throw error;\n  return data;\n}\n\nexport async function deleteCandidate(id: string) {\n  const { error } = await supabase.from(\"candidates\").delete().eq(\"id\", id);\n  if (error) throw error;\n  return true;\n}\n\n/**\n * Upsert: crea o actualiza un candidate por user_id, email o linkedin_id\n */\nexport async function upsertCandidate(candidateData: {\n  user_id?: string;\n  email?: string;\n  full_name?: string;\n  current_company?: string | null;\n  current_job_title?: string | null;\n  linkedin_url?: string | null;\n}): Promise<any> {\n  // Buscar candidate existente\n  let existing = null;\n\n  // Prioridad 1: Buscar por user_id (m√°s confiable)\n  if (candidateData.user_id) {\n    const { data } = await supabase\n      .from(\"candidates\")\n      .select(\"*\")\n      .eq(\"user_id\", candidateData.user_id)\n      .maybeSingle();\n    existing = data;\n  }\n\n  // Prioridad 2: Buscar por email si no se encontr√≥ por user_id\n  if (!existing && candidateData.email) {\n    const { data } = await supabase\n      .from(\"candidates\")\n      .select(\"*\")\n      .eq(\"email\", candidateData.email)\n      .maybeSingle();\n    existing = data;\n  }\n\n  if (existing) {\n    // Actualizar\n    const { data, error } = await supabase\n      .from(\"candidates\")\n      .update({\n        ...candidateData,\n        updated_at: new Date().toISOString(),\n      })\n      .eq(\"id\", existing.id)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  } else {\n    // Crear nuevo\n    return await createCandidate(candidateData, { triggerMatching: true });\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;AAEO,eAAe;IACpB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,cAAc,MAAM,CAAC;IACjE,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,iBAAiB,EAAU;IAC/C,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,cAAc,MAAM,CAAC,KAAK,EAAE,CAAC,MAAM,IAAI,WAAW;IAC9F,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAKO,eAAe,gBACpB,SAAc,EACd,OAAuC;IAEvC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,cACL,MAAM,CAAC,WACP,MAAM,GACN,MAAM;IAET,IAAI,OAAO,MAAM;IAEjB,+CAA+C;IAC/C,IAAI,SAAS,mBAAmB,MAAM,IAAI;QACxC,6CAA6C;QAC7C,wHACG,IAAI,CAAC,CAAC,EAAE,yBAAyB,EAAE;YAClC,0BAA0B,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC;gBACxC,QAAQ,KAAK,CAAC,0DAA0D;YAC1E;QACF,GACC,KAAK,CAAC,CAAC;YACN,QAAQ,KAAK,CAAC,kCAAkC;QAClD;IACJ;IAEA,2CAA2C;IAC3C,IAAI,MAAM,IAAI;QACZ,sIACG,IAAI,CAAC,CAAC,EAAE,oDAAoD,EAAE;YAC7D,qDAAqD,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC;gBACnE,QAAQ,KAAK,CAAC,mEAAmE;YACnF;QACF,GACC,KAAK,CAAC,CAAC;YACN,QAAQ,KAAK,CAAC,2CAA2C;QAC3D;IACJ;IAEA,OAAO;AACT;AAEO,eAAe,gBAAgB,EAAU,EAAE,OAAY;IAC5D,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,cAAc,MAAM,CAAC,SAAS,EAAE,CAAC,MAAM,IAAI,MAAM,GAAG,MAAM;IACtG,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,gBAAgB,EAAU;IAC9C,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,cAAc,MAAM,GAAG,EAAE,CAAC,MAAM;IACtE,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAKO,eAAe,gBAAgB,aAOrC;IACC,6BAA6B;IAC7B,IAAI,WAAW;IAEf,kDAAkD;IAClD,IAAI,cAAc,OAAO,EAAE;QACzB,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,yJAAQ,CAC5B,IAAI,CAAC,cACL,MAAM,CAAC,KACP,EAAE,CAAC,WAAW,cAAc,OAAO,EACnC,WAAW;QACd,WAAW;IACb;IAEA,8DAA8D;IAC9D,IAAI,CAAC,YAAY,cAAc,KAAK,EAAE;QACpC,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,yJAAQ,CAC5B,IAAI,CAAC,cACL,MAAM,CAAC,KACP,EAAE,CAAC,SAAS,cAAc,KAAK,EAC/B,WAAW;QACd,WAAW;IACb;IAEA,IAAI,UAAU;QACZ,aAAa;QACb,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,cACL,MAAM,CAAC;YACN,GAAG,aAAa;YAChB,YAAY,IAAI,OAAO,WAAW;QACpC,GACC,EAAE,CAAC,MAAM,SAAS,EAAE,EACpB,MAAM,GACN,MAAM;QAET,IAAI,OAAO,MAAM;QACjB,OAAO;IACT,OAAO;QACL,cAAc;QACd,OAAO,MAAM,gBAAgB,eAAe;YAAE,iBAAiB;QAAK;IACtE;AACF"}},
    {"offset": {"line": 398, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/hyperconnectors.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getAllHyperconnectors() {\n  const { data, error } = await supabase.from(\"hyperconnectors\").select(\"*\");\n  if (error) throw error;\n  return data;\n}\n\nexport async function getHyperconnectorById(id: string) {\n  const { data, error } = await supabase.from(\"hyperconnectors\").select(\"*\").eq(\"id\", id).single();\n  if (error) throw error;\n  return data;\n}\n\nexport async function createHyperconnector(hci: any) {\n  const { data, error } = await supabase.from(\"hyperconnectors\").insert(hci).select().single();\n  if (error) throw error;\n\n  // Trigger relationship sync (non-blocking)\n  if (data?.id) {\n    import(\"../agents/syncHyperconnectorRelationships\")\n      .then(({ syncHyperconnectorCandidateRelationshipsForHyperconnector }) => {\n        syncHyperconnectorCandidateRelationshipsForHyperconnector(data.id).catch((err) => {\n          console.error(\"Error in background relationship sync after hyperconnector creation:\", err);\n        });\n      })\n      .catch((err) => {\n        console.error(\"Error loading relationship sync module:\", err);\n      });\n  }\n\n  return data;\n}\n\nexport async function updateHyperconnector(id: string, updates: any) {\n  const { data, error } = await supabase.from(\"hyperconnectors\").update(updates).eq(\"id\", id).select().single();\n  if (error) throw error;\n  return data;\n}\n\nexport async function deleteHyperconnector(id: string) {\n  const { error } = await supabase.from(\"hyperconnectors\").delete().eq(\"id\", id);\n  if (error) throw error;\n  return true;\n}\n\n/**\n * Upsert: crea o actualiza un hyperconnector por user_id, email o candidate_id\n */\nexport async function upsertHyperconnector(hyperconnectorData: {\n  user_id?: string;\n  email?: string;\n  full_name?: string;\n  candidate_id?: string;\n  linkedin_url?: string | null;\n}): Promise<any> {\n  // Buscar hyperconnector existente\n  let existing = null;\n\n  // Prioridad 1: Buscar por user_id (m√°s confiable)\n  if (hyperconnectorData.user_id) {\n    const { data } = await supabase\n      .from(\"hyperconnectors\")\n      .select(\"*\")\n      .eq(\"user_id\", hyperconnectorData.user_id)\n      .maybeSingle();\n    existing = data;\n  }\n\n  // Prioridad 2: Buscar por email si no se encontr√≥ por user_id\n  if (!existing && hyperconnectorData.email) {\n    const { data } = await supabase\n      .from(\"hyperconnectors\")\n      .select(\"*\")\n      .eq(\"email\", hyperconnectorData.email)\n      .maybeSingle();\n    existing = data;\n  }\n\n  // Prioridad 3: Buscar por candidate_id si no se encontr√≥ por user_id ni email\n  if (!existing && hyperconnectorData.candidate_id) {\n    const { data } = await supabase\n      .from(\"hyperconnectors\")\n      .select(\"*\")\n      .eq(\"candidate_id\", hyperconnectorData.candidate_id)\n      .maybeSingle();\n    existing = data;\n  }\n\n  if (existing) {\n    // Actualizar\n    const { data, error } = await supabase\n      .from(\"hyperconnectors\")\n      .update({\n        ...hyperconnectorData,\n        updated_at: new Date().toISOString(),\n      })\n      .eq(\"id\", existing.id)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  } else {\n    // Crear nuevo\n    return await createHyperconnector(hyperconnectorData);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;AAEO,eAAe;IACpB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC;IACtE,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,sBAAsB,EAAU;IACpD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC,KAAK,EAAE,CAAC,MAAM,IAAI,MAAM;IAC9F,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,qBAAqB,GAAQ;IACjD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC,KAAK,MAAM,GAAG,MAAM;IAC1F,IAAI,OAAO,MAAM;IAEjB,2CAA2C;IAC3C,IAAI,MAAM,IAAI;QACZ,sIACG,IAAI,CAAC,CAAC,EAAE,yDAAyD,EAAE;YAClE,0DAA0D,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC;gBACxE,QAAQ,KAAK,CAAC,wEAAwE;YACxF;QACF,GACC,KAAK,CAAC,CAAC;YACN,QAAQ,KAAK,CAAC,2CAA2C;QAC3D;IACJ;IAEA,OAAO;AACT;AAEO,eAAe,qBAAqB,EAAU,EAAE,OAAY;IACjE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,CAAC,SAAS,EAAE,CAAC,MAAM,IAAI,MAAM,GAAG,MAAM;IAC3G,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,qBAAqB,EAAU;IACnD,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,GAAG,EAAE,CAAC,MAAM;IAC3E,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAKO,eAAe,qBAAqB,kBAM1C;IACC,kCAAkC;IAClC,IAAI,WAAW;IAEf,kDAAkD;IAClD,IAAI,mBAAmB,OAAO,EAAE;QAC9B,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,yJAAQ,CAC5B,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,WAAW,mBAAmB,OAAO,EACxC,WAAW;QACd,WAAW;IACb;IAEA,8DAA8D;IAC9D,IAAI,CAAC,YAAY,mBAAmB,KAAK,EAAE;QACzC,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,yJAAQ,CAC5B,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,SAAS,mBAAmB,KAAK,EACpC,WAAW;QACd,WAAW;IACb;IAEA,8EAA8E;IAC9E,IAAI,CAAC,YAAY,mBAAmB,YAAY,EAAE;QAChD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,yJAAQ,CAC5B,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,gBAAgB,mBAAmB,YAAY,EAClD,WAAW;QACd,WAAW;IACb;IAEA,IAAI,UAAU;QACZ,aAAa;QACb,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,mBACL,MAAM,CAAC;YACN,GAAG,kBAAkB;YACrB,YAAY,IAAI,OAAO,WAAW;QACpC,GACC,EAAE,CAAC,MAAM,SAAS,EAAE,EACpB,MAAM,GACN,MAAM;QAET,IAAI,OAAO,MAAM;QACjB,OAAO;IACT,OAAO;QACL,cAAc;QACd,OAAO,MAAM,qBAAqB;IACpC;AACF"}},
    {"offset": {"line": 484, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/utils/session.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from \"jose\";\nimport { cookies } from \"next/headers\";\nimport { UserRole } from \"../domain/users\";\n\nconst SECRET_KEY = process.env.SESSION_SECRET || process.env.RECOMMENDATION_SECRET || \"fallback-secret-key-change-in-production\";\nconst secret = new TextEncoder().encode(SECRET_KEY);\n\nexport interface SessionData {\n  userId: string;\n  role: UserRole;\n  candidateId?: string | null;\n  hyperconnectorId?: string | null;\n  email: string;\n  fullName: string;\n}\n\n/**\n * Crea una sesi√≥n JWT y la guarda en una cookie httpOnly\n */\nexport async function createSession(data: SessionData): Promise<string> {\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 d√≠as\n\n  const token = await new SignJWT({\n    userId: data.userId,\n    role: data.role,\n    candidateId: data.candidateId,\n    hyperconnectorId: data.hyperconnectorId,\n    email: data.email,\n    fullName: data.fullName,\n  })\n    .setProtectedHeader({ alg: \"HS256\" })\n    .setIssuedAt()\n    .setExpirationTime(expiresAt)\n    .sign(secret);\n\n  return token;\n}\n\n/**\n * Verifica y obtiene los datos de la sesi√≥n desde la cookie\n */\nexport async function getSession(): Promise<SessionData | null> {\n  try {\n    const cookieStore = await cookies();\n    const token = cookieStore.get(\"session\")?.value;\n\n    if (!token) {\n      return null;\n    }\n\n    const { payload } = await jwtVerify(token, secret);\n    \n    return {\n      userId: payload.userId as string,\n      role: payload.role as UserRole,\n      candidateId: (payload.candidateId as string) || null,\n      hyperconnectorId: (payload.hyperconnectorId as string) || null,\n      email: payload.email as string,\n      fullName: payload.fullName as string,\n    };\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Obtiene la sesi√≥n desde un token string (√∫til para API routes)\n */\nexport async function getSessionFromToken(token: string): Promise<SessionData | null> {\n  try {\n    const { payload } = await jwtVerify(token, secret);\n    \n    return {\n      userId: payload.userId as string,\n      role: payload.role as UserRole,\n      candidateId: (payload.candidateId as string) || null,\n      hyperconnectorId: (payload.hyperconnectorId as string) || null,\n      email: payload.email as string,\n      fullName: payload.fullName as string,\n    };\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Elimina la sesi√≥n (logout)\n */\nexport async function deleteSession(): Promise<void> {\n  const cookieStore = await cookies();\n  cookieStore.delete(\"session\");\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AACA;;;AAGA,MAAM,aAAa,QAAQ,GAAG,CAAC,cAAc,IAAI,QAAQ,GAAG,CAAC,qBAAqB,IAAI;AACtF,MAAM,SAAS,IAAI,cAAc,MAAM,CAAC;AAcjC,eAAe,cAAc,IAAiB;IACnD,MAAM,YAAY,IAAI,KAAK,KAAK,GAAG,KAAK,IAAI,KAAK,KAAK,KAAK,OAAO,SAAS;IAE3E,MAAM,QAAQ,MAAM,IAAI,kLAAO,CAAC;QAC9B,QAAQ,KAAK,MAAM;QACnB,MAAM,KAAK,IAAI;QACf,aAAa,KAAK,WAAW;QAC7B,kBAAkB,KAAK,gBAAgB;QACvC,OAAO,KAAK,KAAK;QACjB,UAAU,KAAK,QAAQ;IACzB,GACG,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,WAClB,IAAI,CAAC;IAER,OAAO;AACT;AAKO,eAAe;IACpB,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,4JAAO;QACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,YAAY;QAE1C,IAAI,CAAC,OAAO;YACV,OAAO;QACT;QAEA,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sLAAS,EAAC,OAAO;QAE3C,OAAO;YACL,QAAQ,QAAQ,MAAM;YACtB,MAAM,QAAQ,IAAI;YAClB,aAAa,AAAC,QAAQ,WAAW,IAAe;YAChD,kBAAkB,AAAC,QAAQ,gBAAgB,IAAe;YAC1D,OAAO,QAAQ,KAAK;YACpB,UAAU,QAAQ,QAAQ;QAC5B;IACF,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAKO,eAAe,oBAAoB,KAAa;IACrD,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sLAAS,EAAC,OAAO;QAE3C,OAAO;YACL,QAAQ,QAAQ,MAAM;YACtB,MAAM,QAAQ,IAAI;YAClB,aAAa,AAAC,QAAQ,WAAW,IAAe;YAChD,kBAAkB,AAAC,QAAQ,gBAAgB,IAAe;YAC1D,OAAO,QAAQ,KAAK;YACpB,UAAU,QAAQ,QAAQ;QAC5B;IACF,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAKO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4JAAO;IACjC,YAAY,MAAM,CAAC;AACrB"}},
    {"offset": {"line": 558, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/utils/adminWhitelist.ts"],"sourcesContent":["/**\n * Whitelist de emails autorizados para el rol de admin\n * En producci√≥n, esto deber√≠a estar en la base de datos o en variables de entorno\n */\n\nconst ADMIN_EMAILS = process.env.ADMIN_EMAILS\n  ? process.env.ADMIN_EMAILS.split(\",\").map((email) => email.trim().toLowerCase())\n  : [\n      // Emails por defecto para desarrollo (puedes agregar m√°s)\n      \"admin@referal.com\",\n    ];\n\n/**\n * Verifica si un email est√° autorizado para ser admin\n */\nexport function isAdminAuthorized(email: string): boolean {\n  return ADMIN_EMAILS.includes(email.toLowerCase());\n}\n\n/**\n * Obtiene la lista de emails autorizados\n */\nexport function getAdminEmails(): string[] {\n  return [...ADMIN_EMAILS];\n}\n\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY,GACzC,QAAQ,GAAG,CAAC,YAAY,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,QAAU,MAAM,IAAI,GAAG,WAAW,MAC3E;IACE,0DAA0D;IAC1D;CACD;AAKE,SAAS,kBAAkB,KAAa;IAC7C,OAAO,aAAa,QAAQ,CAAC,MAAM,WAAW;AAChD;AAKO,SAAS;IACd,OAAO;WAAI;KAAa;AAC1B"}},
    {"offset": {"line": 583, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/app/api/auth/linkedin/callback/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { resolve } from \"path\";\nimport dotenv from \"dotenv\";\nimport { cookies } from \"next/headers\";\nimport { jwtVerify } from \"jose\";\nimport {\n  exchangeCodeForToken,\n  getUserInfo,\n  getProfile,\n  parseHeadline,\n  buildLinkedInUrl,\n} from \"../../../../../src/utils/linkedinAuth\";\nimport { upsertUser, updateLastLogin } from \"../../../../../src/domain/users\";\nimport { upsertCandidate } from \"../../../../../src/domain/candidates\";\nimport { upsertHyperconnector } from \"../../../../../src/domain/hyperconnectors\";\nimport { createSession } from \"../../../../../src/utils/session\";\nimport { isAdminAuthorized } from \"../../../../../src/utils/adminWhitelist\";\n\n// Cargar variables de entorno\nif (!process.env.SESSION_SECRET) {\n  dotenv.config({ path: resolve(process.cwd(), \".env.local\") });\n}\n\nconst SECRET_KEY = process.env.SESSION_SECRET || process.env.RECOMMENDATION_SECRET || \"fallback-secret-key\";\nconst secret = new TextEncoder().encode(SECRET_KEY);\n\n/**\n * GET /api/auth/linkedin/callback\n * Procesa el callback de LinkedIn OAuth\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const code = searchParams.get(\"code\");\n    const state = searchParams.get(\"state\");\n    const error = searchParams.get(\"error\");\n\n    // Verificar si LinkedIn retorn√≥ un error\n    if (error) {\n      console.error(\"Error de LinkedIn:\", error);\n      return NextResponse.redirect(\n        new URL(\"/solicitante/login-simulado?error=linkedin_auth_failed\", request.url)\n      );\n    }\n\n    if (!code || !state) {\n      return NextResponse.redirect(\n        new URL(\"/solicitante/login-simulado?error=missing_params\", request.url)\n      );\n    }\n\n    // Validar state anti-CSRF\n    const cookieStore = await cookies();\n    const storedState = cookieStore.get(\"oauth_state\")?.value;\n\n    if (!storedState || storedState !== state) {\n      return NextResponse.redirect(\n        new URL(\"/solicitante/login-simulado?error=invalid_state\", request.url)\n      );\n    }\n\n    // Verificar y decodificar el state para obtener el rol\n    let role: string;\n    try {\n      const { payload } = await jwtVerify(storedState, secret);\n      role = (payload as any).role;\n    } catch (error) {\n      return NextResponse.redirect(\n        new URL(\"/solicitante/login-simulado?error=invalid_state\", request.url)\n      );\n    }\n\n    // Limpiar cookie de state\n    cookieStore.delete(\"oauth_state\");\n\n    console.log(\"üîÑ Intercambiando c√≥digo por token...\");\n    // Intercambiar c√≥digo por token\n    let accessToken: string;\n    try {\n      accessToken = await exchangeCodeForToken(code);\n      console.log(\"‚úÖ Token obtenido exitosamente\");\n    } catch (error: any) {\n      console.error(\"‚ùå Error intercambiando c√≥digo por token:\", error);\n      throw new Error(`Error obteniendo token de LinkedIn: ${error.message}`);\n    }\n\n    console.log(\"üîÑ Obteniendo informaci√≥n del usuario...\");\n    // Obtener informaci√≥n del usuario\n    let userInfo: any;\n    let profile: any;\n    try {\n      userInfo = await getUserInfo(accessToken);\n      console.log(\"‚úÖ UserInfo obtenido:\", { email: userInfo.email, sub: userInfo.sub });\n      \n      profile = await getProfile(accessToken);\n      console.log(\"‚úÖ Profile obtenido:\", profile ? \"S√≠\" : \"No\");\n    } catch (error: any) {\n      console.error(\"‚ùå Error obteniendo informaci√≥n del usuario:\", error);\n      throw new Error(`Error obteniendo informaci√≥n de LinkedIn: ${error.message}`);\n    }\n\n    // Parsear datos\n    const linkedinId = userInfo.sub;\n    const email = userInfo.email || userInfo.name?.toLowerCase().replace(/\\s+/g, \".\") + \"@linkedin.com\";\n    const fullName = userInfo.name || `${userInfo.given_name || \"\"} ${userInfo.family_name || \"\"}`.trim() || \"Usuario\";\n    \n    console.log(\"üìã Datos parseados:\", { linkedinId, email, fullName });\n    \n    const { current_role, current_company } = parseHeadline(profile?.headline);\n    const linkedinUrl = buildLinkedInUrl(profile?.vanityName);\n    \n    // Mapear current_role a current_job_title para la tabla users\n    const current_job_title = current_role;\n    \n    console.log(\"üìã Headline parseado:\", { current_job_title, current_company, linkedinUrl });\n\n    // Procesar seg√∫n el rol\n    if (role === \"admin\") {\n      // Validar whitelist\n      if (!isAdminAuthorized(email)) {\n        return NextResponse.redirect(\n          new URL(\"/solicitante/login-simulado?error=unauthorized_admin\", request.url)\n        );\n      }\n\n      // Upsert user\n      const user = await upsertUser({\n        email,\n        full_name: fullName,\n        role: \"admin\",\n        linkedin_id: linkedinId,\n        linkedin_url: linkedinUrl,\n        current_job_title,\n        current_company,\n        auth_provider: \"linkedin\",\n        provider_user_id: linkedinId,\n      });\n\n      await updateLastLogin(user.id);\n\n      // Crear sesi√≥n\n      const sessionToken = await createSession({\n        userId: user.id,\n        role: \"admin\",\n        email: user.email,\n        fullName: user.full_name,\n      });\n\n      // Guardar sesi√≥n en cookie\n      cookieStore.set(\"session\", sessionToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        sameSite: \"lax\",\n        maxAge: 7 * 24 * 60 * 60, // 7 d√≠as\n        path: \"/\",\n      });\n\n      return NextResponse.redirect(new URL(\"/admin/solicitudes\", request.url));\n    }\n\n    if (role === \"solicitante\") {\n      console.log(\"üíæ Paso 1: Creando/actualizando user...\");\n      // 1. Crear/actualizar USER primero\n      const user = await upsertUser({\n        email,\n        full_name: fullName,\n        role: \"solicitante\",\n        linkedin_id: linkedinId,\n        linkedin_url: linkedinUrl,\n        current_job_title,\n        current_company,\n        auth_provider: \"linkedin\",\n        provider_user_id: linkedinId,\n      });\n\n      console.log(\"üíæ Paso 2: Creando/actualizando candidate con user_id...\");\n      // 2. Crear/actualizar CANDIDATE con user_id\n      const candidate = await upsertCandidate({\n        user_id: user.id,\n        email,\n        full_name: fullName,\n        current_company: current_company,\n        current_job_title: current_job_title,\n        linkedin_url: linkedinUrl,\n      });\n\n      await updateLastLogin(user.id);\n\n      // Crear sesi√≥n\n      const sessionToken = await createSession({\n        userId: user.id,\n        role: \"solicitante\",\n        candidateId: candidate.id,\n        email: user.email,\n        fullName: user.full_name,\n      });\n\n      // Guardar sesi√≥n en cookie\n      cookieStore.set(\"session\", sessionToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        sameSite: \"lax\",\n        maxAge: 7 * 24 * 60 * 60, // 7 d√≠as\n        path: \"/\",\n      });\n\n      return NextResponse.redirect(new URL(\"/solicitante/solicitudes\", request.url));\n    }\n\n    if (role === \"hyperconnector\") {\n      console.log(\"üíæ Paso 1: Creando/actualizando user...\");\n      // 1. Crear/actualizar USER primero\n      const user = await upsertUser({\n        email,\n        full_name: fullName,\n        role: \"hyperconnector\",\n        linkedin_id: linkedinId,\n        linkedin_url: linkedinUrl,\n        current_job_title,\n        current_company,\n        auth_provider: \"linkedin\",\n        provider_user_id: linkedinId,\n      });\n\n      console.log(\"üíæ Paso 2: Creando/actualizando candidate con user_id...\");\n      // 2. Crear/actualizar CANDIDATE con user_id\n      const candidate = await upsertCandidate({\n        user_id: user.id,\n        email,\n        full_name: fullName,\n        current_company: current_company,\n        current_job_title: current_job_title,\n        linkedin_url: linkedinUrl,\n      });\n\n      console.log(\"üíæ Paso 3: Creando/actualizando hyperconnector con user_id...\");\n      // 3. Crear/actualizar HYPERCONNECTOR con user_id y candidate_id\n      const hyperconnector = await upsertHyperconnector({\n        user_id: user.id,\n        email,\n        full_name: fullName,\n        candidate_id: candidate.id,\n        linkedin_url: linkedinUrl,\n      });\n\n      await updateLastLogin(user.id);\n\n      // Crear sesi√≥n\n      const sessionToken = await createSession({\n        userId: user.id,\n        role: \"hyperconnector\",\n        candidateId: candidate.id,\n        hyperconnectorId: hyperconnector.id,\n        email: user.email,\n        fullName: user.full_name,\n      });\n\n      // Guardar sesi√≥n en cookie\n      cookieStore.set(\"session\", sessionToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        sameSite: \"lax\",\n        maxAge: 7 * 24 * 60 * 60, // 7 d√≠as\n        path: \"/\",\n      });\n\n      return NextResponse.redirect(new URL(\"/hyperconnector/jobs-home\", request.url));\n    }\n\n    // Rol no reconocido\n    return NextResponse.redirect(\n      new URL(\"/solicitante/login-simulado?error=invalid_role\", request.url)\n    );\n  } catch (error: any) {\n    console.error(\"‚ùå Error en /api/auth/linkedin/callback:\", error);\n    console.error(\"Stack:\", error.stack);\n    \n    // Limpiar cookies de sesi√≥n y state en caso de error\n    const cookieStore = await cookies();\n    cookieStore.delete(\"oauth_state\");\n    cookieStore.delete(\"session\");\n    \n    // Determinar el tipo de error para mostrar mensaje apropiado\n    let errorCode = \"auth_error\";\n    if (error.message?.includes(\"token\")) {\n      errorCode = \"token_error\";\n    } else if (error.message?.includes(\"userinfo\")) {\n      errorCode = \"userinfo_error\";\n    }\n    \n    return NextResponse.redirect(\n      new URL(`/solicitante/login-simulado?error=${errorCode}`, request.url)\n    );\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}