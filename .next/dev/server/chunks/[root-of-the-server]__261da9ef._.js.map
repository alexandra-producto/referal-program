{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/db/supabaseClient.ts"],"sourcesContent":["import { resolve } from \"path\";\nimport dotenv from \"dotenv\";\nimport { createClient } from \"@supabase/supabase-js\";\n\n// Carga .env.local desde la raíz del proyecto\ndotenv.config({ path: resolve(process.cwd(), \".env.local\") });\n\nconst url = process.env.SUPABASE_URL;\nconst key = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!url || !key) {\n  console.error(\"SUPABASE_URL:\", url);\n  console.error(\"SUPABASE_SERVICE_ROLE_KEY:\", key);\n  throw new Error(\"❌ Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY.\");\n}\n\nexport const supabase = createClient(url, key);\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,8CAA8C;AAC9C,kKAAM,CAAC,MAAM,CAAC;IAAE,MAAM,IAAA,4GAAO,EAAC,QAAQ,GAAG,IAAI;AAAc;AAE3D,MAAM,MAAM,QAAQ,GAAG,CAAC,YAAY;AACpC,MAAM,MAAM,QAAQ,GAAG,CAAC,yBAAyB;AAEjD,IAAI,CAAC,OAAO,CAAC,KAAK;IAChB,QAAQ,KAAK,CAAC,iBAAiB;IAC/B,QAAQ,KAAK,CAAC,8BAA8B;IAC5C,MAAM,IAAI,MAAM;AAClB;AAEO,MAAM,WAAW,IAAA,yNAAY,EAAC,KAAK"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/utils/recommendationTokens.ts"],"sourcesContent":["import crypto from \"crypto\";\nimport { resolve } from \"path\";\nimport dotenv from \"dotenv\";\n\n// Cargar variables de entorno si no están ya cargadas\nif (!process.env.RECOMMENDATION_SECRET) {\n  dotenv.config({ path: resolve(process.cwd(), \".env.local\") });\n}\n\n/**\n * Genera un token único y seguro para un link de recomendación\n * El token contiene información codificada sobre el HCI y el Job\n */\nexport function generateRecommendationToken(\n  hyperconnectorId: string,\n  jobId: string\n): string {\n  // Crear un payload simple\n  const payload = `${hyperconnectorId}:${jobId}:${Date.now()}`;\n  \n  // Generar un hash único usando SHA256\n  const secret = process.env.RECOMMENDATION_SECRET || \"default-secret\";\n  const hash = crypto\n    .createHash(\"sha256\")\n    .update(payload + secret)\n    .digest(\"hex\");\n  \n  // Tomar los primeros 32 caracteres para un token más corto\n  const token = hash.substring(0, 32);\n  \n  // Codificar el payload en base64url para poder decodificarlo después\n  const encodedPayload = Buffer.from(payload).toString(\"base64url\");\n  \n  // Combinar: token + payload codificado (separados por punto)\n  return `${token}.${encodedPayload}`;\n}\n\n/**\n * Valida y decodifica un token de recomendación\n * Retorna null si el token es inválido\n */\nexport function validateRecommendationToken(\n  token: string\n): { hyperconnectorId: string; jobId: string; timestamp: number } | null {\n  try {\n    const parts = token.split(\".\");\n    if (parts.length !== 2) return null;\n    \n    const [hashPart, encodedPayload] = parts;\n    \n    // Decodificar el payload\n    const payload = Buffer.from(encodedPayload, \"base64url\").toString(\"utf-8\");\n    const [hyperconnectorId, jobId, timestampStr] = payload.split(\":\");\n    \n    if (!hyperconnectorId || !jobId || !timestampStr) return null;\n    \n    // Validar el hash\n    const secret = process.env.RECOMMENDATION_SECRET || \"default-secret\";\n    const expectedHash = crypto\n      .createHash(\"sha256\")\n      .update(payload + secret)\n      .digest(\"hex\")\n      .substring(0, 32);\n    \n    if (hashPart !== expectedHash) {\n      console.warn(\"❌ Hash mismatch:\", {\n        received: hashPart,\n        expected: expectedHash.substring(0, 10) + \"...\",\n        secretLength: secret.length,\n        payload: payload.substring(0, 50) + \"...\"\n      });\n      return null;\n    }\n    \n    // Verificar que el token no sea muy viejo (opcional: 30 días)\n    const timestamp = parseInt(timestampStr, 10);\n    const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 días en ms\n    if (Date.now() - timestamp > maxAge) return null;\n    \n    return {\n      hyperconnectorId,\n      jobId,\n      timestamp,\n    };\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Normaliza la URL base para asegurar que localhost use http://\n */\nfunction normalizeBaseUrl(url: string): string {\n  if (!url) return \"http://localhost:3000\";\n  \n  // Si es localhost, forzar http://\n  if (url.includes(\"localhost\") || url.includes(\"127.0.0.1\")) {\n    return url.replace(/^https?:\\/\\//, \"http://\");\n  }\n  \n  // Para otras URLs, mantener el protocolo original o usar https:// por defecto\n  if (!url.match(/^https?:\\/\\//)) {\n    return `https://${url}`;\n  }\n  \n  return url;\n}\n\n/**\n * Genera la URL completa de recomendación\n */\nexport function generateRecommendationUrl(\n  hyperconnectorId: string,\n  jobId: string,\n  baseUrl: string = process.env.APP_URL || \"http://localhost:3000\"\n): string {\n  const normalizedUrl = normalizeBaseUrl(baseUrl);\n  const token = generateRecommendationToken(hyperconnectorId, jobId);\n  // Asegurar que no haya doble slash\n  const cleanUrl = normalizedUrl.replace(/\\/$/, \"\");\n  return `${cleanUrl}/recommend/${token}`;\n}\n\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAEA,sDAAsD;AACtD,IAAI,CAAC,QAAQ,GAAG,CAAC,qBAAqB,EAAE;IACtC,kKAAM,CAAC,MAAM,CAAC;QAAE,MAAM,IAAA,4GAAO,EAAC,QAAQ,GAAG,IAAI;IAAc;AAC7D;AAMO,SAAS,4BACd,gBAAwB,EACxB,KAAa;IAEb,0BAA0B;IAC1B,MAAM,UAAU,GAAG,iBAAiB,CAAC,EAAE,MAAM,CAAC,EAAE,KAAK,GAAG,IAAI;IAE5D,sCAAsC;IACtC,MAAM,SAAS,QAAQ,GAAG,CAAC,qBAAqB,IAAI;IACpD,MAAM,OAAO,gHAAM,CAChB,UAAU,CAAC,UACX,MAAM,CAAC,UAAU,QACjB,MAAM,CAAC;IAEV,2DAA2D;IAC3D,MAAM,QAAQ,KAAK,SAAS,CAAC,GAAG;IAEhC,qEAAqE;IACrE,MAAM,iBAAiB,OAAO,IAAI,CAAC,SAAS,QAAQ,CAAC;IAErD,6DAA6D;IAC7D,OAAO,GAAG,MAAM,CAAC,EAAE,gBAAgB;AACrC;AAMO,SAAS,4BACd,KAAa;IAEb,IAAI;QACF,MAAM,QAAQ,MAAM,KAAK,CAAC;QAC1B,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;QAE/B,MAAM,CAAC,UAAU,eAAe,GAAG;QAEnC,yBAAyB;QACzB,MAAM,UAAU,OAAO,IAAI,CAAC,gBAAgB,aAAa,QAAQ,CAAC;QAClE,MAAM,CAAC,kBAAkB,OAAO,aAAa,GAAG,QAAQ,KAAK,CAAC;QAE9D,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,cAAc,OAAO;QAEzD,kBAAkB;QAClB,MAAM,SAAS,QAAQ,GAAG,CAAC,qBAAqB,IAAI;QACpD,MAAM,eAAe,gHAAM,CACxB,UAAU,CAAC,UACX,MAAM,CAAC,UAAU,QACjB,MAAM,CAAC,OACP,SAAS,CAAC,GAAG;QAEhB,IAAI,aAAa,cAAc;YAC7B,QAAQ,IAAI,CAAC,oBAAoB;gBAC/B,UAAU;gBACV,UAAU,aAAa,SAAS,CAAC,GAAG,MAAM;gBAC1C,cAAc,OAAO,MAAM;gBAC3B,SAAS,QAAQ,SAAS,CAAC,GAAG,MAAM;YACtC;YACA,OAAO;QACT;QAEA,8DAA8D;QAC9D,MAAM,YAAY,SAAS,cAAc;QACzC,MAAM,SAAS,KAAK,KAAK,KAAK,KAAK,MAAM,gBAAgB;QACzD,IAAI,KAAK,GAAG,KAAK,YAAY,QAAQ,OAAO;QAE5C,OAAO;YACL;YACA;YACA;QACF;IACF,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAEA;;CAEC,GACD,SAAS,iBAAiB,GAAW;IACnC,IAAI,CAAC,KAAK,OAAO;IAEjB,kCAAkC;IAClC,IAAI,IAAI,QAAQ,CAAC,gBAAgB,IAAI,QAAQ,CAAC,cAAc;QAC1D,OAAO,IAAI,OAAO,CAAC,gBAAgB;IACrC;IAEA,8EAA8E;IAC9E,IAAI,CAAC,IAAI,KAAK,CAAC,iBAAiB;QAC9B,OAAO,CAAC,QAAQ,EAAE,KAAK;IACzB;IAEA,OAAO;AACT;AAKO,SAAS,0BACd,gBAAwB,EACxB,KAAa,EACb,UAAkB,QAAQ,GAAG,CAAC,OAAO,IAAI,uBAAuB;IAEhE,MAAM,gBAAgB,iBAAiB;IACvC,MAAM,QAAQ,4BAA4B,kBAAkB;IAC5D,mCAAmC;IACnC,MAAM,WAAW,cAAc,OAAO,CAAC,OAAO;IAC9C,OAAO,GAAG,SAAS,WAAW,EAAE,OAAO;AACzC"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/recommendationLinks.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\nimport { generateRecommendationToken, validateRecommendationToken } from \"../utils/recommendationTokens\";\nimport { resolve } from \"path\";\nimport dotenv from \"dotenv\";\n\n// Asegurar que las variables de entorno estén cargadas\nif (!process.env.RECOMMENDATION_SECRET) {\n  dotenv.config({ path: resolve(process.cwd(), \".env.local\") });\n}\n\n/**\n * Crea un registro de link de recomendación en la base de datos\n * Esto nos permite trackear qué links se han enviado y cuándo\n */\nexport async function createRecommendationLink(\n  hyperconnectorId: string,\n  jobId: string\n) {\n  const token = generateRecommendationToken(hyperconnectorId, jobId);\n  \n  const { data, error } = await supabase\n    .from(\"recommendation_links\")\n    .insert({\n      hyperconnector_id: hyperconnectorId,\n      job_id: jobId,\n      token: token,\n      created_at: new Date().toISOString(),\n      expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 días\n    })\n    .select()\n    .single();\n\n  if (error) {\n    // Si la tabla no existe, retornamos solo el token (modo fallback)\n    console.warn(\"⚠️ recommendation_links table might not exist:\", error.message);\n    return { token };\n  }\n\n  return data;\n}\n\n/**\n * Valida un token y retorna la información del link\n */\nexport async function validateRecommendationLink(token: string) {\n  // Primero validar el token criptográficamente\n  const decoded = validateRecommendationToken(token);\n  if (!decoded) return null;\n\n  // Luego verificar en la BD (si la tabla existe)\n  const { data, error } = await supabase\n    .from(\"recommendation_links\")\n    .select(\"*\")\n    .eq(\"token\", token)\n    .single();\n\n  if (error) {\n    // Si la tabla no existe, confiar solo en la validación criptográfica\n    console.warn(\"⚠️ recommendation_links table might not exist:\", error.message);\n    return decoded;\n  }\n\n  if (!data) return null;\n\n  // Verificar que no haya expirado\n  if (new Date(data.expires_at) < new Date()) {\n    return null;\n  }\n\n  return {\n    hyperconnectorId: data.hyperconnector_id,\n    jobId: data.job_id,\n    timestamp: decoded.timestamp,\n  };\n}\n\n/**\n * Marca un link como usado (opcional, para analytics)\n */\nexport async function markRecommendationLinkAsUsed(token: string) {\n  const { error } = await supabase\n    .from(\"recommendation_links\")\n    .update({ used_at: new Date().toISOString() })\n    .eq(\"token\", token);\n\n  if (error) {\n    console.warn(\"⚠️ Could not mark link as used:\", error.message);\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,uDAAuD;AACvD,IAAI,CAAC,QAAQ,GAAG,CAAC,qBAAqB,EAAE;IACtC,kKAAM,CAAC,MAAM,CAAC;QAAE,MAAM,IAAA,4GAAO,EAAC,QAAQ,GAAG,IAAI;IAAc;AAC7D;AAMO,eAAe,yBACpB,gBAAwB,EACxB,KAAa;IAEb,MAAM,QAAQ,IAAA,qLAA2B,EAAC,kBAAkB;IAE5D,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,wBACL,MAAM,CAAC;QACN,mBAAmB;QACnB,QAAQ;QACR,OAAO;QACP,YAAY,IAAI,OAAO,WAAW;QAClC,YAAY,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,MAAM,WAAW;IACzE,GACC,MAAM,GACN,MAAM;IAET,IAAI,OAAO;QACT,kEAAkE;QAClE,QAAQ,IAAI,CAAC,kDAAkD,MAAM,OAAO;QAC5E,OAAO;YAAE;QAAM;IACjB;IAEA,OAAO;AACT;AAKO,eAAe,2BAA2B,KAAa;IAC5D,8CAA8C;IAC9C,MAAM,UAAU,IAAA,qLAA2B,EAAC;IAC5C,IAAI,CAAC,SAAS,OAAO;IAErB,gDAAgD;IAChD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,wBACL,MAAM,CAAC,KACP,EAAE,CAAC,SAAS,OACZ,MAAM;IAET,IAAI,OAAO;QACT,qEAAqE;QACrE,QAAQ,IAAI,CAAC,kDAAkD,MAAM,OAAO;QAC5E,OAAO;IACT;IAEA,IAAI,CAAC,MAAM,OAAO;IAElB,iCAAiC;IACjC,IAAI,IAAI,KAAK,KAAK,UAAU,IAAI,IAAI,QAAQ;QAC1C,OAAO;IACT;IAEA,OAAO;QACL,kBAAkB,KAAK,iBAAiB;QACxC,OAAO,KAAK,MAAM;QAClB,WAAW,QAAQ,SAAS;IAC9B;AACF;AAKO,eAAe,6BAA6B,KAAa;IAC9D,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAC7B,IAAI,CAAC,wBACL,MAAM,CAAC;QAAE,SAAS,IAAI,OAAO,WAAW;IAAG,GAC3C,EAAE,CAAC,SAAS;IAEf,IAAI,OAAO;QACT,QAAQ,IAAI,CAAC,mCAAmC,MAAM,OAAO;IAC/D;AACF"}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/recommendations.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getRecommendationsForJob(jobId: string) {\n  const { data, error } = await supabase\n    .from(\"recommendations\")\n    .select(\"*\")\n    .eq(\"job_id\", jobId);\n\n  if (error) throw error;\n  return data;\n}\n\nexport async function createRecommendation(payload: any) {\n  const { data, error } = await supabase\n    .from(\"recommendations\")\n    .insert(payload)\n    .select()\n    .single();\n\n  if (error) throw error;\n  return data;\n}\n\nexport async function updateRecommendation(id: string, updates: any) {\n  const { data, error } = await supabase\n    .from(\"recommendations\")\n    .update(updates)\n    .eq(\"id\", id)\n    .select()\n    .single();\n\n  if (error) throw error;\n  return data;\n}\n\nexport async function deleteRecommendation(id: string) {\n  const { error } = await supabase.from(\"recommendations\").delete().eq(\"id\", id);\n  if (error) throw error;\n  return true;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEO,eAAe,yBAAyB,KAAa;IAC1D,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,UAAU;IAEhB,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,qBAAqB,OAAY;IACrD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,mBACL,MAAM,CAAC,SACP,MAAM,GACN,MAAM;IAET,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,qBAAqB,EAAU,EAAE,OAAY;IACjE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,mBACL,MAAM,CAAC,SACP,EAAE,CAAC,MAAM,IACT,MAAM,GACN,MAAM;IAET,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,qBAAqB,EAAU;IACnD,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,mBAAmB,MAAM,GAAG,EAAE,CAAC,MAAM;IAC3E,IAAI,OAAO,MAAM;IACjB,OAAO;AACT"}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/app/api/recommend/%5Btoken%5D/submit/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { validateRecommendationLink, markRecommendationLinkAsUsed } from \"../../../../../src/domain/recommendationLinks\";\nimport { createRecommendation } from \"../../../../../src/domain/recommendations\";\n\n/**\n * POST /api/recommend/[token]/submit\n * Crea una recomendación para uno o más candidatos\n */\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ token: string }> }\n) {\n  try {\n    const { token } = await params;\n\n    // Validar el token\n    const linkData = await validateRecommendationLink(token);\n    if (!linkData) {\n      return NextResponse.json(\n        { error: \"Token inválido o expirado\" },\n        { status: 401 }\n      );\n    }\n\n    // linkData puede tener hyperconnectorId/jobId directamente o en propiedades diferentes\n    const hyperconnectorId = linkData.hyperconnectorId || (linkData as any).hyperconnector_id;\n    const jobId = linkData.jobId || (linkData as any).job_id;\n    \n    if (!hyperconnectorId || !jobId) {\n      return NextResponse.json(\n        { error: \"Token inválido: faltan datos\" },\n        { status: 401 }\n      );\n    }\n\n    // Obtener datos del body\n    const body = await request.json();\n    const { candidateIds, notes, linkedinUrl } = body;\n\n    // Permitir recomendaciones sin candidatos si hay LinkedIn URL (recomendación personalizada)\n    if ((!candidateIds || !Array.isArray(candidateIds) || candidateIds.length === 0) && !linkedinUrl) {\n      return NextResponse.json(\n        { error: \"Debes seleccionar al menos un candidato o proporcionar una URL de LinkedIn\" },\n        { status: 400 }\n      );\n    }\n\n    // Crear recomendaciones para cada candidato\n    const recommendations = [];\n    \n    if (candidateIds && candidateIds.length > 0) {\n      const candidateRecommendations = await Promise.all(\n        candidateIds.map((candidateId: string) =>\n          createRecommendation({\n            hyperconnector_id: hyperconnectorId,\n            job_id: jobId,\n            candidate_id: candidateId,\n            notes: notes || null,\n            status: \"pending\",\n            created_at: new Date().toISOString(),\n          })\n        )\n      );\n      recommendations.push(...candidateRecommendations);\n    }\n\n    // Si hay LinkedIn URL, crear una recomendación personalizada\n    if (linkedinUrl) {\n      const customRecommendation = await createRecommendation({\n        hyperconnector_id: hyperconnectorId,\n        job_id: jobId,\n        candidate_id: null, // null para recomendaciones personalizadas\n        notes: notes || null,\n        linkedin_url: linkedinUrl,\n        status: \"pending\",\n        created_at: new Date().toISOString(),\n      });\n      recommendations.push(customRecommendation);\n    }\n\n    // Marcar el link como usado\n    await markRecommendationLinkAsUsed(token);\n\n    return NextResponse.json({\n      success: true,\n      recommendations,\n      message: `Recomendación${recommendations.length > 1 ? \"es\" : \"\"} creada${recommendations.length > 1 ? \"s\" : \"\"} exitosamente`,\n    });\n  } catch (error: any) {\n    console.error(\"Error en POST /api/recommend/[token]/submit:\", error);\n    return NextResponse.json(\n      { error: \"Error al crear la recomendación\" },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,KACpB,OAAoB,EACpB,EAAE,MAAM,EAA0C;IAElD,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM;QAExB,mBAAmB;QACnB,MAAM,WAAW,MAAM,IAAA,oLAA0B,EAAC;QAClD,IAAI,CAAC,UAAU;YACb,OAAO,gKAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4B,GACrC;gBAAE,QAAQ;YAAI;QAElB;QAEA,uFAAuF;QACvF,MAAM,mBAAmB,SAAS,gBAAgB,IAAI,AAAC,SAAiB,iBAAiB;QACzF,MAAM,QAAQ,SAAS,KAAK,IAAI,AAAC,SAAiB,MAAM;QAExD,IAAI,CAAC,oBAAoB,CAAC,OAAO;YAC/B,OAAO,gKAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA+B,GACxC;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,YAAY,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG;QAE7C,4FAA4F;QAC5F,IAAI,CAAC,CAAC,gBAAgB,CAAC,MAAM,OAAO,CAAC,iBAAiB,aAAa,MAAM,KAAK,CAAC,KAAK,CAAC,aAAa;YAChG,OAAO,gKAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA6E,GACtF;gBAAE,QAAQ;YAAI;QAElB;QAEA,4CAA4C;QAC5C,MAAM,kBAAkB,EAAE;QAE1B,IAAI,gBAAgB,aAAa,MAAM,GAAG,GAAG;YAC3C,MAAM,2BAA2B,MAAM,QAAQ,GAAG,CAChD,aAAa,GAAG,CAAC,CAAC,cAChB,IAAA,0KAAoB,EAAC;oBACnB,mBAAmB;oBACnB,QAAQ;oBACR,cAAc;oBACd,OAAO,SAAS;oBAChB,QAAQ;oBACR,YAAY,IAAI,OAAO,WAAW;gBACpC;YAGJ,gBAAgB,IAAI,IAAI;QAC1B;QAEA,6DAA6D;QAC7D,IAAI,aAAa;YACf,MAAM,uBAAuB,MAAM,IAAA,0KAAoB,EAAC;gBACtD,mBAAmB;gBACnB,QAAQ;gBACR,cAAc;gBACd,OAAO,SAAS;gBAChB,cAAc;gBACd,QAAQ;gBACR,YAAY,IAAI,OAAO,WAAW;YACpC;YACA,gBAAgB,IAAI,CAAC;QACvB;QAEA,4BAA4B;QAC5B,MAAM,IAAA,sLAA4B,EAAC;QAEnC,OAAO,gKAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,SAAS,CAAC,aAAa,EAAE,gBAAgB,MAAM,GAAG,IAAI,OAAO,GAAG,OAAO,EAAE,gBAAgB,MAAM,GAAG,IAAI,MAAM,GAAG,aAAa,CAAC;QAC/H;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,gDAAgD;QAC9D,OAAO,gKAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAkC,GAC3C;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}