{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/jobs.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getJobById(id: string) {\n  const { data, error } = await supabase\n    .from(\"jobs\")\n    .select(\"*\")\n    .eq(\"id\", id)\n    .maybeSingle();\n\n  if (error) throw new Error(error.message);\n  return data;\n}\n\n// Para este test: buscar el rol de Vemo por nombre de empresa\nexport async function getJobByCompanyNameLike(company: string) {\n  const { data, error } = await supabase\n    .from(\"jobs\")\n    .select(\"*\")\n    .ilike(\"company_name\", `%${company}%`)\n    .limit(1)\n    .maybeSingle();\n\n  if (error) throw new Error(error.message);\n  return data;\n}\n\n/**\n * Creates a new job and optionally triggers matching with all candidates\n */\nexport async function createJob(\n  job: any,\n  options?: { triggerMatching?: boolean }\n) {\n  const { data, error } = await supabase\n    .from(\"jobs\")\n    .insert(job)\n    .select()\n    .single();\n\n  if (error) throw new Error(error.message);\n\n  // Trigger matching if requested (non-blocking)\n  if (options?.triggerMatching && data?.id) {\n    // Run asynchronously to not block the insert\n    import(\"../agents/matchJobCandidate\")\n      .then(({ matchJobWithAllCandidates }) => {\n        matchJobWithAllCandidates(data.id).catch((err) => {\n          console.error(\"Error in background matching after job creation:\", err);\n        });\n      })\n      .catch((err) => {\n        console.error(\"Error loading matching module:\", err);\n      });\n  }\n\n  return data;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,eAAe,WAAW,EAAU;IACzC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,QACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,IACT,WAAW;IAEd,IAAI,OAAO,MAAM,IAAI,MAAM,MAAM,OAAO;IACxC,OAAO;AACT;AAGO,eAAe,wBAAwB,OAAe;IAC3D,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,QACL,MAAM,CAAC,KACP,KAAK,CAAC,gBAAgB,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EACpC,KAAK,CAAC,GACN,WAAW;IAEd,IAAI,OAAO,MAAM,IAAI,MAAM,MAAM,OAAO;IACxC,OAAO;AACT;AAKO,eAAe,UACpB,GAAQ,EACR,OAAuC;IAEvC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,QACL,MAAM,CAAC,KACP,MAAM,GACN,MAAM;IAET,IAAI,OAAO,MAAM,IAAI,MAAM,MAAM,OAAO;IAExC,+CAA+C;IAC/C,IAAI,SAAS,mBAAmB,MAAM,IAAI;QACxC,6CAA6C;QAC7C,wHACG,IAAI,CAAC,CAAC,EAAE,yBAAyB,EAAE;YAClC,0BAA0B,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC;gBACxC,QAAQ,KAAK,CAAC,oDAAoD;YACpE;QACF,GACC,KAAK,CAAC,CAAC;YACN,QAAQ,KAAK,CAAC,kCAAkC;QAClD;IACJ;IAEA,OAAO;AACT"}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/candidateExperience.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getExperienceForCandidate(candidateId: string) {\n  const { data, error } = await supabase\n    .from(\"candidate_experience\")\n    .select(\"*\")\n    .eq(\"candidate_id\", candidateId)\n    .order(\"start_date\", { ascending: false });\n\n  if (error) throw error;\n  return data || [];\n}\n\nexport async function insertExperienceRecords(records: any[]) {\n  if (!records.length) return [];\n  const { data, error } = await supabase\n    .from(\"candidate_experience\")\n    .insert(records)\n    .select();\n\n  if (error) throw error;\n  return data || [];\n}\n\nexport async function deleteExperienceForCandidate(candidateId: string) {\n  const { error } = await supabase\n    .from(\"candidate_experience\")\n    .delete()\n    .eq(\"candidate_id\", candidateId);\n\n  if (error) throw error;\n  return true;\n}\n\nexport async function getAllCandidates() {\n  const { data, error } = await supabase.from(\"candidates\").select(\"*\");\n  if (error) throw error;\n  return data || [];\n}\n\nexport async function getCandidatesNeedingExperience(limit = 50) {\n  const { data, error } = await supabase\n    .rpc(\"candidates_needing_experience\", { p_limit: limit }); // si decides usar una función\n  if (error) throw error;\n  return data || [];\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAEO,eAAe,0BAA0B,WAAmB;IACjE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,wBACL,MAAM,CAAC,KACP,EAAE,CAAC,gBAAgB,aACnB,KAAK,CAAC,cAAc;QAAE,WAAW;IAAM;IAE1C,IAAI,OAAO,MAAM;IACjB,OAAO,QAAQ,EAAE;AACnB;AAEO,eAAe,wBAAwB,OAAc;IAC1D,IAAI,CAAC,QAAQ,MAAM,EAAE,OAAO,EAAE;IAC9B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,wBACL,MAAM,CAAC,SACP,MAAM;IAET,IAAI,OAAO,MAAM;IACjB,OAAO,QAAQ,EAAE;AACnB;AAEO,eAAe,6BAA6B,WAAmB;IACpE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAC7B,IAAI,CAAC,wBACL,MAAM,GACN,EAAE,CAAC,gBAAgB;IAEtB,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAAC,IAAI,CAAC,cAAc,MAAM,CAAC;IACjE,IAAI,OAAO,MAAM;IACjB,OAAO,QAAQ,EAAE;AACnB;AAEO,eAAe,+BAA+B,QAAQ,EAAE;IAC7D,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,GAAG,CAAC,iCAAiC;QAAE,SAAS;IAAM,IAAI,8BAA8B;IAC3F,IAAI,OAAO,MAAM;IACjB,OAAO,QAAQ,EAAE;AACnB"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/domain/jobCandidateMatches.ts"],"sourcesContent":["import { supabase } from \"../db/supabaseClient\";\n\nexport async function getMatchesForJob(jobId: string) {\n  const { data, error } = await supabase\n    .from(\"job_candidate_matches\")\n    .select(\"*\")\n    .eq(\"job_id\", jobId);\n\n  if (error) throw error;\n  return data;\n}\n\nexport async function createOrUpdateJobCandidateMatch(payload: any) {\n  // First, try to find existing match\n  const { data: existing } = await supabase\n    .from(\"job_candidate_matches\")\n    .select(\"id\")\n    .eq(\"job_id\", payload.job_id)\n    .eq(\"candidate_id\", payload.candidate_id)\n    .maybeSingle();\n\n  if (existing) {\n    // Update existing match\n    const { data, error } = await supabase\n      .from(\"job_candidate_matches\")\n      .update({\n        match_score: payload.match_score,\n        match_detail: payload.match_detail,\n        match_source: payload.match_source || \"auto\",\n        updated_at: payload.updated_at || new Date().toISOString(),\n      })\n      .eq(\"id\", existing.id)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  } else {\n    // Insert new match\n    const { data, error } = await supabase\n      .from(\"job_candidate_matches\")\n      .insert({\n        ...payload,\n        created_at: payload.created_at || new Date().toISOString(),\n        updated_at: payload.updated_at || new Date().toISOString(),\n      })\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  }\n}\n\nexport async function deleteJobCandidateMatch(jobId: string, candidateId: string) {\n  const { error } = await supabase\n    .from(\"job_candidate_matches\")\n    .delete()\n    .eq(\"job_id\", jobId)\n    .eq(\"candidate_id\", candidateId);\n\n  if (error) throw error;\n  return true;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,eAAe,iBAAiB,KAAa;IAClD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,yBACL,MAAM,CAAC,KACP,EAAE,CAAC,UAAU;IAEhB,IAAI,OAAO,MAAM;IACjB,OAAO;AACT;AAEO,eAAe,gCAAgC,OAAY;IAChE,oCAAoC;IACpC,MAAM,EAAE,MAAM,QAAQ,EAAE,GAAG,MAAM,yJAAQ,CACtC,IAAI,CAAC,yBACL,MAAM,CAAC,MACP,EAAE,CAAC,UAAU,QAAQ,MAAM,EAC3B,EAAE,CAAC,gBAAgB,QAAQ,YAAY,EACvC,WAAW;IAEd,IAAI,UAAU;QACZ,wBAAwB;QACxB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,yBACL,MAAM,CAAC;YACN,aAAa,QAAQ,WAAW;YAChC,cAAc,QAAQ,YAAY;YAClC,cAAc,QAAQ,YAAY,IAAI;YACtC,YAAY,QAAQ,UAAU,IAAI,IAAI,OAAO,WAAW;QAC1D,GACC,EAAE,CAAC,MAAM,SAAS,EAAE,EACpB,MAAM,GACN,MAAM;QAET,IAAI,OAAO,MAAM;QACjB,OAAO;IACT,OAAO;QACL,mBAAmB;QACnB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CACnC,IAAI,CAAC,yBACL,MAAM,CAAC;YACN,GAAG,OAAO;YACV,YAAY,QAAQ,UAAU,IAAI,IAAI,OAAO,WAAW;YACxD,YAAY,QAAQ,UAAU,IAAI,IAAI,OAAO,WAAW;QAC1D,GACC,MAAM,GACN,MAAM;QAET,IAAI,OAAO,MAAM;QACjB,OAAO;IACT;AACF;AAEO,eAAe,wBAAwB,KAAa,EAAE,WAAmB;IAC9E,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,yJAAQ,CAC7B,IAAI,CAAC,yBACL,MAAM,GACN,EAAE,CAAC,UAAU,OACb,EAAE,CAAC,gBAAgB;IAEtB,IAAI,OAAO,MAAM;IACjB,OAAO;AACT"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/agents/computeJobCandidateMatch.ts"],"sourcesContent":["/**\n * Automatic Job-Candidate Matching System\n * \n * Computes a match score (0-100) between a job and a candidate based on:\n * - Seniority (25%)\n * - Role/Skills (35%)\n * - Industry fit (20%)\n * - Location & Language (20%)\n */\n\n// Configuration: weights for each component (should sum to 1.0)\nexport const MATCH_WEIGHTS = {\n  seniority: 0.25,\n  skills: 0.35,\n  industry: 0.20,\n  location_language: 0.20,\n} as const;\n\n// Seniority levels mapping\nconst SENIORITY_LEVELS: Record<string, number> = {\n  intern: 1,\n  junior: 2,\n  mid: 3,\n  mid_senior: 3.5,\n  senior: 4,\n  lead: 5,\n  principal: 5,\n  director: 6,\n  vp: 7,\n  c_level: 8,\n};\n\n// Industry keywords mapping for inference\nconst INDUSTRY_KEYWORDS: Record<string, string[]> = {\n  mobility: [\"mobility\", \"transport\", \"uber\", \"lyft\", \"ride\", \"taxi\", \"delivery\", \"logistics\"],\n  ev_charging: [\"ev\", \"electric\", \"charging\", \"vehicle\", \"tesla\", \"battery\"],\n  consumer_apps: [\"consumer\", \"mobile\", \"app\", \"ios\", \"android\", \"b2c\"],\n  saas: [\"saas\", \"software\", \"b2b\", \"enterprise\", \"platform\"],\n  fintech: [\"fintech\", \"finance\", \"payment\", \"banking\", \"crypto\"],\n  ecommerce: [\"ecommerce\", \"retail\", \"marketplace\", \"shopping\"],\n};\n\n// Type definitions\nexport interface Job {\n  id: string;\n  company_name: string;\n  job_title: string;\n  job_level?: string | null;\n  location?: string | null;\n  remote_ok?: boolean | null;\n  description?: string | null;\n  requirements_json?: {\n    languages?: string[];\n    seniority?: string;\n    industries?: string[];\n    must_have_skills?: string[];\n    location_preference?: string[];\n    nice_to_have_skills?: string[];\n  } | null;\n}\n\nexport interface Candidate {\n  id: string;\n  full_name: string;\n  email?: string | null;\n  linkedin_url?: string | null;\n  current_job_title?: string | null;\n  current_company?: string | null;\n  industry?: string | null;\n  seniority?: string | null;\n  country?: string | null;\n}\n\nexport interface CandidateExperience {\n  id: string;\n  candidate_id: string;\n  company_name?: string | null;\n  role_title?: string | null;\n  start_date?: string | null;\n  end_date?: string | null;\n  location?: string | null;\n  description?: string | null;\n  experience_source?: string | null;\n}\n\nexport interface MatchResult {\n  score: number; // 0-100 with 2 decimal precision\n  detail: {\n    summary: string;\n    components: {\n      seniority: number; // 0-1\n      skills: number; // 0-1\n      industry: number; // 0-1\n      location_language: number; // 0-1\n    };\n    strong_fit: string[];\n    gaps: string[];\n  };\n}\n\n/**\n * Normalizes text for comparison (lowercase, trim)\n */\nfunction normalizeText(text: string | null | undefined): string {\n  if (!text) return \"\";\n  return text.toLowerCase().trim();\n}\n\n/**\n * Checks if a text contains any of the given keywords\n */\nfunction containsKeywords(text: string, keywords: string[]): boolean {\n  const normalized = normalizeText(text);\n  return keywords.some((keyword) => normalized.includes(normalizeText(keyword)));\n}\n\n/**\n * Calculates seniority match score (0-1)\n */\nfunction calculateSeniorityScore(\n  jobSeniority: string | null | undefined,\n  candidateSeniority: string | null | undefined,\n  experiences: CandidateExperience[]\n): number {\n  const jobLevel = normalizeText(jobSeniority);\n  const candidateLevel = normalizeText(candidateSeniority);\n\n  // Exact match\n  if (jobLevel && candidateLevel && jobLevel === candidateLevel) {\n    return 1.0;\n  }\n\n  // If both have seniority, compare levels\n  if (jobLevel && candidateLevel) {\n    const jobNum = SENIORITY_LEVELS[jobLevel] || 3;\n    const candidateNum = SENIORITY_LEVELS[candidateLevel] || 3;\n    const diff = Math.abs(jobNum - candidateNum);\n\n    if (diff === 0) return 1.0;\n    if (diff === 0.5) return 0.8;\n    if (diff === 1) return 0.6;\n    if (diff === 2) return 0.4;\n    return 0.2; // Large gap\n  }\n\n  // Infer from job titles in experience\n  if (jobLevel && !candidateLevel && experiences.length > 0) {\n    const roleTitles = experiences\n      .map((exp) => normalizeText(exp.role_title))\n      .join(\" \");\n\n    // Check for seniority indicators in role titles\n    const hasSenior = roleTitles.includes(\"senior\") || roleTitles.includes(\"lead\") || roleTitles.includes(\"principal\");\n    const hasMid = roleTitles.includes(\"mid\");\n    const hasJunior = roleTitles.includes(\"junior\") || roleTitles.includes(\"intern\");\n\n    if (jobLevel.includes(\"senior\") && hasSenior) return 0.8;\n    if (jobLevel.includes(\"senior\") && hasMid) return 0.5;\n    if (jobLevel.includes(\"mid\") && hasMid) return 0.8;\n    if (jobLevel.includes(\"junior\") && hasJunior) return 0.8;\n\n    // Count years of experience (rough estimate)\n    const yearsOfExperience = experiences.length * 2; // Rough estimate\n    if (jobLevel.includes(\"senior\") && yearsOfExperience >= 5) return 0.7;\n    if (jobLevel.includes(\"mid\") && yearsOfExperience >= 2) return 0.7;\n  }\n\n  // Default partial score if we can't determine\n  return 0.5;\n}\n\n/**\n * Calculates skills match score (0-1)\n */\nfunction calculateSkillsScore(\n  job: Job,\n  candidate: Candidate,\n  experiences: CandidateExperience[]\n): number {\n  const requirements = job.requirements_json;\n  if (!requirements) return 0.5; // Default if no requirements\n\n  const mustHaveSkills = requirements.must_have_skills || [];\n  const niceToHaveSkills = requirements.nice_to_have_skills || [];\n\n  if (mustHaveSkills.length === 0 && niceToHaveSkills.length === 0) {\n    return 0.5; // No skills to match\n  }\n\n  // Build searchable text from candidate\n  const searchableText = [\n    normalizeText(candidate.current_job_title),\n    normalizeText(candidate.industry),\n    ...experiences.map((exp) => normalizeText(exp.role_title)),\n    ...experiences.map((exp) => normalizeText(exp.description)),\n    ...experiences.map((exp) => normalizeText(exp.company_name)),\n  ].join(\" \");\n\n  // Count matches\n  let mustHaveMatches = 0;\n  let niceToHaveMatches = 0;\n\n  for (const skill of mustHaveSkills) {\n    if (containsKeywords(searchableText, [skill])) {\n      mustHaveMatches++;\n    }\n  }\n\n  for (const skill of niceToHaveSkills) {\n    if (containsKeywords(searchableText, [skill])) {\n      niceToHaveMatches++;\n    }\n  }\n\n  // Calculate score: must-have skills are more important\n  const mustHaveWeight = 0.7;\n  const niceToHaveWeight = 0.3;\n\n  const mustHaveScore =\n    mustHaveSkills.length > 0\n      ? mustHaveMatches / mustHaveSkills.length\n      : 0;\n  const niceToHaveScore =\n    niceToHaveSkills.length > 0\n      ? niceToHaveMatches / niceToHaveSkills.length\n      : 0;\n\n  // Penalize heavily for missing must-have skills\n  const baseScore =\n    mustHaveScore * mustHaveWeight + niceToHaveScore * niceToHaveWeight;\n\n  // If we have 0 must-have matches but there are must-have skills, heavily penalize\n  if (mustHaveSkills.length > 0 && mustHaveMatches === 0) {\n    return baseScore * 0.3; // Heavy penalty\n  }\n\n  return Math.min(1.0, baseScore);\n}\n\n/**\n * Calculates industry match score (0-1)\n */\nfunction calculateIndustryScore(\n  job: Job,\n  candidate: Candidate,\n  experiences: CandidateExperience[]\n): number {\n  const requirements = job.requirements_json;\n  const jobIndustries = requirements?.industries || [];\n\n  if (jobIndustries.length === 0) return 0.5; // Default if no industry specified\n\n  // Build searchable text\n  const searchableText = [\n    normalizeText(candidate.industry),\n    ...experiences.map((exp) => normalizeText(exp.company_name)),\n    ...experiences.map((exp) => normalizeText(exp.role_title)),\n    ...experiences.map((exp) => normalizeText(exp.description)),\n  ].join(\" \");\n\n  // Check for exact industry matches\n  let industryMatches = 0;\n  for (const industry of jobIndustries) {\n    const keywords = INDUSTRY_KEYWORDS[industry] || [industry];\n    if (containsKeywords(searchableText, keywords)) {\n      industryMatches++;\n    }\n  }\n\n  // Exact match\n  if (industryMatches === jobIndustries.length) return 1.0;\n  if (industryMatches > 0) return 0.6 + (industryMatches / jobIndustries.length) * 0.3;\n\n  // Check if it's still tech/product/SaaS (partial credit)\n  const techKeywords = [\"tech\", \"software\", \"saas\", \"product\", \"startup\", \"digital\"];\n  const isTechRelated = containsKeywords(searchableText, techKeywords);\n  if (isTechRelated) return 0.4;\n\n  // Completely unrelated\n  return 0.2;\n}\n\n/**\n * Calculates location and language match score (0-1)\n */\nfunction calculateLocationLanguageScore(\n  job: Job,\n  candidate: Candidate,\n  experiences: CandidateExperience[]\n): number {\n  const requirements = job.requirements_json;\n  const locationPreferences = requirements?.location_preference || [];\n  const requiredLanguages = requirements?.languages || [];\n\n  let locationScore = 0.5; // Default\n  let languageScore = 0.5; // Default\n\n  // Location matching\n  if (locationPreferences.length > 0 && candidate.country) {\n    const candidateCountry = normalizeText(candidate.country);\n    const candidateLocation = normalizeText(\n      experiences.find((exp) => exp.location)?.location || \"\"\n    );\n\n    for (const pref of locationPreferences) {\n      const normalizedPref = normalizeText(pref);\n      if (\n        candidateCountry.includes(normalizedPref) ||\n        normalizedPref.includes(candidateCountry) ||\n        candidateLocation.includes(normalizedPref)\n      ) {\n        locationScore = 1.0;\n        break;\n      }\n\n      // Check for \"Latam\" as a region\n      if (\n        (normalizedPref.includes(\"latam\") || normalizedPref.includes(\"latin\")) &&\n        (candidateCountry.includes(\"mexico\") ||\n          candidateCountry.includes(\"colombia\") ||\n          candidateCountry.includes(\"argentina\") ||\n          candidateCountry.includes(\"chile\") ||\n          candidateCountry.includes(\"brazil\") ||\n          candidateCountry.includes(\"peru\"))\n      ) {\n        locationScore = 0.9;\n      }\n    }\n\n    // If remote_ok, give partial credit even if location doesn't match\n    if (job.remote_ok && locationScore < 0.5) {\n      locationScore = 0.6;\n    }\n  } else if (job.remote_ok) {\n    // If remote_ok and no location preference, give full credit\n    locationScore = 1.0;\n  }\n\n  // Language matching\n  if (requiredLanguages.length > 0) {\n    // For now, assume Latam-based product managers likely speak Spanish and some English\n    // This is a heuristic - in the future, we could add a languages field to candidates\n    const isLatamBased =\n      candidate.country &&\n      containsKeywords(normalizeText(candidate.country), [\n        \"mexico\",\n        \"colombia\",\n        \"argentina\",\n        \"chile\",\n        \"peru\",\n        \"brazil\",\n      ]);\n\n    if (isLatamBased) {\n      const needsSpanish = requiredLanguages.some((lang) =>\n        normalizeText(lang).includes(\"spanish\")\n      );\n      const needsEnglish = requiredLanguages.some((lang) =>\n        normalizeText(lang).includes(\"english\")\n      );\n\n      if (needsSpanish) languageScore += 0.3; // Spanish likely\n      if (needsEnglish) languageScore += 0.2; // English likely (partial)\n    }\n\n    // If only English required and candidate is from English-speaking country\n    if (\n      requiredLanguages.length === 1 &&\n      normalizeText(requiredLanguages[0]).includes(\"english\") &&\n      candidate.country &&\n      containsKeywords(normalizeText(candidate.country), [\n        \"usa\",\n        \"united states\",\n        \"uk\",\n        \"united kingdom\",\n        \"canada\",\n        \"australia\",\n      ])\n    ) {\n      languageScore = 1.0;\n    }\n\n    languageScore = Math.min(1.0, languageScore);\n  } else {\n    languageScore = 1.0; // No language requirement\n  }\n\n  // Average of location and language\n  return (locationScore + languageScore) / 2;\n}\n\n/**\n * Generates human-readable summary and gaps\n */\nfunction generateMatchDetail(\n  job: Job,\n  candidate: Candidate,\n  experiences: CandidateExperience[],\n  components: MatchResult[\"detail\"][\"components\"]\n): { summary: string; strong_fit: string[]; gaps: string[] } {\n  const strongFit: string[] = [];\n  const gaps: string[] = [];\n\n  // Strong fits\n  if (components.seniority >= 0.7) {\n    strongFit.push(\n      `Strong seniority match: ${candidate.seniority || \"experienced\"} candidate for ${job.job_level || \"role\"} position.`\n    );\n  }\n\n  if (components.skills >= 0.7) {\n    const requirements = job.requirements_json;\n    const matchedSkills = (requirements?.must_have_skills || []).filter((skill) => {\n      const searchableText = [\n        normalizeText(candidate.current_job_title),\n        ...experiences.map((exp) => normalizeText(exp.role_title)),\n      ].join(\" \");\n      return containsKeywords(searchableText, [skill]);\n    });\n    if (matchedSkills.length > 0) {\n      strongFit.push(\n        `Strong skills match: ${matchedSkills.join(\", \")} experience found.`\n      );\n    }\n  }\n\n  if (components.industry >= 0.7) {\n    strongFit.push(\n      `Strong industry fit: ${candidate.industry || \"relevant industry\"} experience aligns with job requirements.`\n    );\n  }\n\n  if (components.location_language >= 0.8) {\n    strongFit.push(\n      `Location and language alignment: ${candidate.country || \"location\"} matches preferences.`\n    );\n  }\n\n  // Gaps\n  if (components.skills < 0.5) {\n    const requirements = job.requirements_json;\n    const missingSkills = (requirements?.must_have_skills || []).filter((skill) => {\n      const searchableText = [\n        normalizeText(candidate.current_job_title),\n        ...experiences.map((exp) => normalizeText(exp.role_title)),\n      ].join(\" \");\n      return !containsKeywords(searchableText, [skill]);\n    });\n    if (missingSkills.length > 0) {\n      gaps.push(`Missing key skills: ${missingSkills.join(\", \")}.`);\n    }\n  }\n\n  if (components.industry < 0.5) {\n    const requirements = job.requirements_json;\n    const industries = requirements?.industries || [];\n    if (industries.length > 0) {\n      gaps.push(\n        `Limited experience in required industries: ${industries.join(\", \")}.`\n      );\n    }\n  }\n\n  if (components.seniority < 0.5) {\n    gaps.push(\n      `Seniority mismatch: candidate level may not align with ${job.job_level || \"required\"} position.`\n    );\n  }\n\n  // Generate summary\n  const totalScore =\n    components.seniority * MATCH_WEIGHTS.seniority +\n    components.skills * MATCH_WEIGHTS.skills +\n    components.industry * MATCH_WEIGHTS.industry +\n    components.location_language * MATCH_WEIGHTS.location_language;\n\n  let summary = \"\";\n  if (totalScore >= 0.7) {\n    summary = `Strong match: ${candidate.full_name} has relevant experience and aligns well with ${job.job_title} at ${job.company_name}.`;\n  } else if (totalScore >= 0.5) {\n    summary = `Moderate match: ${candidate.full_name} has some relevant experience but may have gaps in specific requirements.`;\n  } else {\n    summary = `Weak match: ${candidate.full_name} has limited alignment with the job requirements.`;\n  }\n\n  return { summary, strong_fit: strongFit, gaps };\n}\n\n/**\n * Main function: computes job-candidate match score\n */\nexport function computeJobCandidateMatch(\n  job: Job,\n  candidate: Candidate,\n  experiences: CandidateExperience[]\n): MatchResult {\n  // Calculate component scores\n  const seniorityScore = calculateSeniorityScore(\n    job.job_level || job.requirements_json?.seniority,\n    candidate.seniority,\n    experiences\n  );\n\n  const skillsScore = calculateSkillsScore(job, candidate, experiences);\n\n  const industryScore = calculateIndustryScore(job, candidate, experiences);\n\n  const locationLanguageScore = calculateLocationLanguageScore(\n    job,\n    candidate,\n    experiences\n  );\n\n  const components = {\n    seniority: seniorityScore,\n    skills: skillsScore,\n    industry: industryScore,\n    location_language: locationLanguageScore,\n  };\n\n  // Calculate weighted total score\n  const totalScore =\n    components.seniority * MATCH_WEIGHTS.seniority +\n    components.skills * MATCH_WEIGHTS.skills +\n    components.industry * MATCH_WEIGHTS.industry +\n    components.location_language * MATCH_WEIGHTS.location_language;\n\n  // Round to 2 decimal places and convert to 0-100 scale\n  const finalScore = Math.round(totalScore * 100 * 100) / 100;\n\n  // Generate detail\n  const { summary, strong_fit, gaps } = generateMatchDetail(\n    job,\n    candidate,\n    experiences,\n    components\n  );\n\n  return {\n    score: finalScore,\n    detail: {\n      summary,\n      components,\n      strong_fit,\n      gaps,\n    },\n  };\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 533, "column": 0}, "map": {"version":3,"sources":["file:///Users/usuario/Referal%20MVP/src/agents/matchJobCandidate.ts"],"sourcesContent":["/**\n * Service to match a job with a candidate and upsert the result\n */\n\nimport { getJobById } from \"../domain/jobs\";\nimport { getCandidateById } from \"../domain/candidates\";\nimport { getExperienceForCandidate } from \"../domain/candidateExperience\";\nimport { createOrUpdateJobCandidateMatch } from \"../domain/jobCandidateMatches\";\nimport { computeJobCandidateMatch, Job, Candidate, CandidateExperience } from \"./computeJobCandidateMatch\";\n\n/**\n * Matches a job with a candidate and saves the result to job_candidate_matches\n */\nexport async function matchJobCandidate(\n  jobId: string,\n  candidateId: string\n): Promise<{ score: number; detail: any }> {\n  // Fetch all required data\n  const job = await getJobById(jobId);\n  if (!job) {\n    throw new Error(`Job not found: ${jobId}`);\n  }\n\n  const candidate = await getCandidateById(candidateId);\n  if (!candidate) {\n    throw new Error(`Candidate not found: ${candidateId}`);\n  }\n\n  const experiences = await getExperienceForCandidate(candidateId);\n\n  // Compute match\n  const matchResult = computeJobCandidateMatch(\n    job as Job,\n    candidate as Candidate,\n    experiences as CandidateExperience[]\n  );\n\n  // Upsert to database\n  await createOrUpdateJobCandidateMatch({\n    job_id: jobId,\n    candidate_id: candidateId,\n    match_score: matchResult.score,\n    match_detail: matchResult.detail,\n    match_source: \"auto\",\n    updated_at: new Date().toISOString(),\n  });\n\n  return {\n    score: matchResult.score,\n    detail: matchResult.detail,\n  };\n}\n\n/**\n * Matches a job with all existing candidates\n */\nexport async function matchJobWithAllCandidates(jobId: string): Promise<number> {\n  const { supabase } = await import(\"../db/supabaseClient\");\n  \n  // Get all candidates\n  const { data: candidates, error } = await supabase\n    .from(\"candidates\")\n    .select(\"id\");\n\n  if (error) {\n    throw new Error(`Error fetching candidates: ${error.message}`);\n  }\n\n  if (!candidates || candidates.length === 0) {\n    console.log(\"No candidates found to match\");\n    return 0;\n  }\n\n  console.log(`Matching job ${jobId} with ${candidates.length} candidates...`);\n\n  let successCount = 0;\n  let errorCount = 0;\n\n  // Process in batches to avoid overwhelming the system\n  const batchSize = 10;\n  for (let i = 0; i < candidates.length; i += batchSize) {\n    const batch = candidates.slice(i, i + batchSize);\n    \n    await Promise.all(\n      batch.map(async (candidate) => {\n        try {\n          await matchJobCandidate(jobId, candidate.id);\n          successCount++;\n        } catch (error: any) {\n          console.error(\n            `Error matching job ${jobId} with candidate ${candidate.id}:`,\n            error.message\n          );\n          errorCount++;\n        }\n      })\n    );\n\n    console.log(`Processed ${Math.min(i + batchSize, candidates.length)}/${candidates.length} candidates`);\n  }\n\n  console.log(`✅ Matching complete: ${successCount} successful, ${errorCount} errors`);\n  return successCount;\n}\n\n/**\n * Matches a candidate with all existing jobs\n */\nexport async function matchCandidateWithAllJobs(candidateId: string): Promise<number> {\n  const { supabase } = await import(\"../db/supabaseClient\");\n  \n  // Get all jobs\n  const { data: jobs, error } = await supabase\n    .from(\"jobs\")\n    .select(\"id\");\n\n  if (error) {\n    throw new Error(`Error fetching jobs: ${error.message}`);\n  }\n\n  if (!jobs || jobs.length === 0) {\n    console.log(\"No jobs found to match\");\n    return 0;\n  }\n\n  console.log(`Matching candidate ${candidateId} with ${jobs.length} jobs...`);\n\n  let successCount = 0;\n  let errorCount = 0;\n\n  // Process in batches\n  const batchSize = 10;\n  for (let i = 0; i < jobs.length; i += batchSize) {\n    const batch = jobs.slice(i, i + batchSize);\n    \n    await Promise.all(\n      batch.map(async (job) => {\n        try {\n          await matchJobCandidate(job.id, candidateId);\n          successCount++;\n        } catch (error: any) {\n          console.error(\n            `Error matching candidate ${candidateId} with job ${job.id}:`,\n            error.message\n          );\n          errorCount++;\n        }\n      })\n    );\n\n    console.log(`Processed ${Math.min(i + batchSize, jobs.length)}/${jobs.length} jobs`);\n  }\n\n  console.log(`✅ Matching complete: ${successCount} successful, ${errorCount} errors`);\n  return successCount;\n}\n\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;AAED;AACA;AACA;AACA;AACA;;;;;;AAKO,eAAe,kBACpB,KAAa,EACb,WAAmB;IAEnB,0BAA0B;IAC1B,MAAM,MAAM,MAAM,IAAA,qJAAU,EAAC;IAC7B,IAAI,CAAC,KAAK;QACR,MAAM,IAAI,MAAM,CAAC,eAAe,EAAE,OAAO;IAC3C;IAEA,MAAM,YAAY,MAAM,IAAA,iKAAgB,EAAC;IACzC,IAAI,CAAC,WAAW;QACd,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,aAAa;IACvD;IAEA,MAAM,cAAc,MAAM,IAAA,mLAAyB,EAAC;IAEpD,gBAAgB;IAChB,MAAM,cAAc,IAAA,uLAAwB,EAC1C,KACA,WACA;IAGF,qBAAqB;IACrB,MAAM,IAAA,yLAA+B,EAAC;QACpC,QAAQ;QACR,cAAc;QACd,aAAa,YAAY,KAAK;QAC9B,cAAc,YAAY,MAAM;QAChC,cAAc;QACd,YAAY,IAAI,OAAO,WAAW;IACpC;IAEA,OAAO;QACL,OAAO,YAAY,KAAK;QACxB,QAAQ,YAAY,MAAM;IAC5B;AACF;AAKO,eAAe,0BAA0B,KAAa;IAC3D,MAAM,EAAE,QAAQ,EAAE,GAAG;IAErB,qBAAqB;IACrB,MAAM,EAAE,MAAM,UAAU,EAAE,KAAK,EAAE,GAAG,MAAM,SACvC,IAAI,CAAC,cACL,MAAM,CAAC;IAEV,IAAI,OAAO;QACT,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,MAAM,OAAO,EAAE;IAC/D;IAEA,IAAI,CAAC,cAAc,WAAW,MAAM,KAAK,GAAG;QAC1C,QAAQ,GAAG,CAAC;QACZ,OAAO;IACT;IAEA,QAAQ,GAAG,CAAC,CAAC,aAAa,EAAE,MAAM,MAAM,EAAE,WAAW,MAAM,CAAC,cAAc,CAAC;IAE3E,IAAI,eAAe;IACnB,IAAI,aAAa;IAEjB,sDAAsD;IACtD,MAAM,YAAY;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,KAAK,UAAW;QACrD,MAAM,QAAQ,WAAW,KAAK,CAAC,GAAG,IAAI;QAEtC,MAAM,QAAQ,GAAG,CACf,MAAM,GAAG,CAAC,OAAO;YACf,IAAI;gBACF,MAAM,kBAAkB,OAAO,UAAU,EAAE;gBAC3C;YACF,EAAE,OAAO,OAAY;gBACnB,QAAQ,KAAK,CACX,CAAC,mBAAmB,EAAE,MAAM,gBAAgB,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,EAC7D,MAAM,OAAO;gBAEf;YACF;QACF;QAGF,QAAQ,GAAG,CAAC,CAAC,UAAU,EAAE,KAAK,GAAG,CAAC,IAAI,WAAW,WAAW,MAAM,EAAE,CAAC,EAAE,WAAW,MAAM,CAAC,WAAW,CAAC;IACvG;IAEA,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,aAAa,aAAa,EAAE,WAAW,OAAO,CAAC;IACnF,OAAO;AACT;AAKO,eAAe,0BAA0B,WAAmB;IACjE,MAAM,EAAE,QAAQ,EAAE,GAAG;IAErB,eAAe;IACf,MAAM,EAAE,MAAM,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SACjC,IAAI,CAAC,QACL,MAAM,CAAC;IAEV,IAAI,OAAO;QACT,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,MAAM,OAAO,EAAE;IACzD;IAEA,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;QAC9B,QAAQ,GAAG,CAAC;QACZ,OAAO;IACT;IAEA,QAAQ,GAAG,CAAC,CAAC,mBAAmB,EAAE,YAAY,MAAM,EAAE,KAAK,MAAM,CAAC,QAAQ,CAAC;IAE3E,IAAI,eAAe;IACnB,IAAI,aAAa;IAEjB,qBAAqB;IACrB,MAAM,YAAY;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,UAAW;QAC/C,MAAM,QAAQ,KAAK,KAAK,CAAC,GAAG,IAAI;QAEhC,MAAM,QAAQ,GAAG,CACf,MAAM,GAAG,CAAC,OAAO;YACf,IAAI;gBACF,MAAM,kBAAkB,IAAI,EAAE,EAAE;gBAChC;YACF,EAAE,OAAO,OAAY;gBACnB,QAAQ,KAAK,CACX,CAAC,yBAAyB,EAAE,YAAY,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,EAC7D,MAAM,OAAO;gBAEf;YACF;QACF;QAGF,QAAQ,GAAG,CAAC,CAAC,UAAU,EAAE,KAAK,GAAG,CAAC,IAAI,WAAW,KAAK,MAAM,EAAE,CAAC,EAAE,KAAK,MAAM,CAAC,KAAK,CAAC;IACrF;IAEA,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,aAAa,aAAa,EAAE,WAAW,OAAO,CAAC;IACnF,OAAO;AACT"}}]
}